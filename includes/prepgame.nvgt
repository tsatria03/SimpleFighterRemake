void buildmenu()
{
setupmenu();
m.add_item_tts("animal", "an");
m.add_item_tts("animal zone", "az");
m.add_item_tts("blockage", "bl");
m.add_item_tts("bomb", "bm");
m.add_item_tts("bomb zone", "bz");
m.add_item_tts("calander", "cn");
m.add_item_tts("checkpoint", "cp");
m.add_item_tts("clock", "cl");
m.add_item_tts("conveyor belt", "cb");
m.add_item_tts("dialog", "dlg");
m.add_item_tts("door", "ds");
m.add_item_tts("enemy", "em");
m.add_item_tts("enemy zone", "ez");
m.add_item_tts("floor breaker", "fbr");
m.add_item_tts("force field", "fld");
m.add_item_tts("hazard", "hd");
m.add_item_tts("heal zone", "hz");
m.add_item_tts("item", "obj");
m.add_item_tts("item zone", "iz");
m.add_item_tts("lift", "lf");
m.add_item_tts("lockable door", "ld");
m.add_item_tts("lockable passage", "lg");
m.add_item_tts("mine", "mn");
m.add_item_tts("moving hazard", "mhd");
m.add_item_tts("moving platform", "mpl");
m.add_item_tts("music ambience", "musamb");
m.add_item_tts("music source", "mus");
m.add_item_tts("passage", "psg");
m.add_item_tts("platform", "pf");
m.add_item_tts("projectile", "pj");
m.add_item_tts("projectile zone", "pz");
m.add_item_tts("reverb", "rev");
m.add_item_tts("robot", "rt");
m.add_item_tts("robot zone", "rz");
m.add_item_tts("sign", "sn");
m.add_item_tts("sound ambience", "srcamb");
m.add_item_tts("sound source", "src");
m.add_item_tts("spike", "sp");
m.add_item_tts("spawnpoint", "st");
m.add_item_tts("staircase", "sf");
m.add_item_tts("teleporter", "tp");
m.add_item_tts("text square", "txt");
m.add_item_tts("time bomb", "tbm");
m.add_item_tts("timed music", "tmc");
m.add_item_tts("timed source", "trc");
m.add_item_tts("timed text", "tmt");
m.add_item_tts("travelpoint", "trp");
m.add_item_tts("turret", "tt");
m.add_item_tts("vanishing platform", "vp");
m.add_item_tts("vehicle", "vh");
m.add_item_tts("wall", "wl");
m.add_item_tts("zombie", "zb");
m.add_item_tts("zombie zone", "zz");
m.add_item_tts("zone", "zn");
m.add_item_tts("add a line", "addline");
m.add_item_tts("edit a line", "editline");
m.add_item_tts("remove a line", "remline");
m.add_item_tts("copy raw map data to clipboard", "clboard");
m.add_item_tts("paste raw map data from clipboard", "clboard2");
m.add_item_tts("delete map", "dcm");
m.add_item_tts("reload map", "rcm");
int mres=m.run("Builder menu",true);
string buildem=m.get_item_name(mres);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(buildem=="srcamb")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","","Enter the minimum x of this sound ambience.");
string mx2=virtual_input_box("","Enter the maximum x of this sound ambience.");
string my=virtual_input_box("","Enter the minimum y of this sound ambience.");
string my2=virtual_input_box("","Enter the maximum y of this sound ambience.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] soundamb=find_directories("data/sounds/"+soundpack+"/objects/sources/*");
if(soundamb.length()==0)
{
dlg_snd("Error. There are no sound ambiences available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=sorcesmenu();
if(res!="")
{
sorcetyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"sound_ambience "+x+" "+paxx+" "+y+" "+paxy+" "+sorcetyp+" "+volume+" "+pitch);
mapper.close();
spawn_ambsource(x, paxx, y, paxy, sorcetyp, volume, pitch);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="musamb")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this music ambience.");
string mx2=virtual_input_box("","Enter the maximum x of this music ambience.");
string my=virtual_input_box("","Enter the minimum y of this music ambience.");
string my2=virtual_input_box("","Enter the maximum y of this music ambience.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] musicamb=find_directories("data/sounds/"+soundpack+"/objects/musics/*");
if(musicamb.length()==0)
{
dlg_snd("Error. There are no music ambiences available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=musicsmenu();
if(res!="")
{
mustyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"music_ambience "+x+" "+paxx+" "+y+" "+paxy+" "+mustyp+" "+volume+" "+pitch);
mapper.close();
spawn_musicamb(x, paxx, y, paxy, mustyp, volume, pitch);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="an")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this animal.");
string my=virtual_input_box("","Enter the y of this animal.");
string rng=virtual_input_box("","Enter the horizontal attack range of this animal.");
string rng2=virtual_input_box("","Enter the vertical attack range of this animal.");
string rng3=virtual_input_box("","Enter the horizontal seeing range of this animal.");
string rng4=virtual_input_box("","Enter the vertical seeing range of this animal.");
string hp=virtual_input_box("","Enter the health of this animal.");
string hc=virtual_input_box("","Enter the maximum lives of this animal.");
string dm=virtual_input_box("","Enter the maximum damage of this animal.");
string ft=virtual_input_box("","Enter the fire time of this animal.");
string sp=virtual_input_box("","Enter the speed of this animal.");
string lev=virtual_input_box("","Enter the level of this animal.");
string exper=virtual_input_box("","Enter the xp of this animal.");
if(x=="" and y=="" and amrange=="" and amrange2=="" and amrange3=="" and amrange4=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
amrange=string_to_number(rng);
amrange2=string_to_number(rng2);
amrange3=string_to_number(rng3);
amrange4=string_to_number(rng4);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] animal=find_directories("data/sounds/"+soundpack+"/npc/normal/animals/*");
if(animal.length()==0)
{
dlg_snd("Error. There are no animals available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=animalsmenu();
if(res!="")
{
amtype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the animal attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the animal move?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the animal folow you up on other platforms?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres5=m.run("Should the animal drop an item after killing it?",true);
if(mres5==0)
{
speak("canceled");
return;
}
if(mres5==1)
{
itms=true;
}
if(mres5==2)
{
itms=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"animal "+x+" "+y+" "+amrange+" "+amrange2+" "+amrange3+" "+amrange4+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+amtype+" "+fb+" "+mb+" "+mb2+" "+itms);
mapper.close();
spawn_animal(x, y, amrange, amrange2, amrange3, amrange4, minhp, minhp, card, damage, firetime, speedtime, lv, xn, amtype, fb, mb, mb2, itms);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="az")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this animal zone.");
string mx2=virtual_input_box("","Enter the maximum x of this animal zone.");
string my=virtual_input_box("","Enter the y of this animal zone.");
string sp=virtual_input_box("","Enter the spawn time of this animal zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] animal=find_directories("data/sounds/"+soundpack+"/npc/normal/animals/*");
if(animal.length()==0)
{
dlg_snd("Error. There are no animals available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=animalsmenu(true);
if(res!="")
{
amtype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"animal_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+amtype);
mapper.close();
spawn_animalzone(x, paxx, y, speedtime, amtype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="bl")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this blockage.");
string mx2=virtual_input_box("","Enter the maximum x of this blockage.");
string my=virtual_input_box("","Enter the minimum y of this blockage.");
string my2=virtual_input_box("","Enter the maximum y of this blockage.");
//input.set_only_allowed_chars("none");
string text=virtual_input_box("","Enter the text of this blockage.");
if(x=="" and paxx=="" and y=="" and paxy=="" and txt=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
txt=text;
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"blockage "+x+" "+paxx+" "+y+" "+paxy+" "+txt);
mapper.close();
spawn_blockage(x, paxx, y, paxy, txt);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="bm")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this bomb.");
string my=virtual_input_box("","Enter the y of this bomb.");
string dm=virtual_input_box("","Enter the maximum damage of this bomb.");
string sp=virtual_input_box("","Enter the speed of this bomb.");
if(x=="" and y=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
string[] bomb=find_directories("data/sounds/"+soundpack+"/objects/bombs/*");
if(bomb.length()==0)
{
dlg_snd("Error. There are no bombs available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=bombsmenu();
if(res!="")
{
botype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"bomb "+x+" "+y+" "+damage+" "+speedtime+" "+botype);
mapper.close();
spawn_bomb(x, y, damage, speedtime, botype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="bz")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this bomb zone.");
string mx2=virtual_input_box("","Enter the maximum x of this bomb zone.");
string my=virtual_input_box("","Enter the y of this bomb zone.");
string sp=virtual_input_box("","Enter the spawn time of this bomb zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] bomb=find_directories("data/sounds/"+soundpack+"/objects/bombs/*");
if(bomb.length()==0)
{
dlg_snd("Error. There are no bombs available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=bombsmenu();
if(res!="")
{
botype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"bomb_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+botype);
mapper.close();
spawn_bombzone(x, paxx, y, speedtime, botype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="cn")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this calander.");
string my=virtual_input_box("","Enter the y of this calander.");
//input.set_only_allowed_chars("none");
string text=virtual_input_box("","Enter the text of this calander.");
if(x=="" and y=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
txt=text;
string[] calander=find_directories("data/sounds/"+soundpack+"/objects/calanders/*");
if(calander.length()==0)
{
dlg_snd("Error. There are no calanders available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=calandersmenu();
if(res!="")
{
calandertyp=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this calendar to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"calander "+x+" "+y+" "+txt+" "+calandertyp+" "+dmd);
mapper.close();
spawn_calander(x, y, txt, calandertyp, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="cl")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this clock.");
string my=virtual_input_box("","Enter the y of this clock.");
//input.set_only_allowed_chars("none");
string text=virtual_input_box("","Enter the text of this clock.");
if(x=="" and y=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
txt=text;
string[] clock=find_directories("data/sounds/"+soundpack+"/objects/clocks/*");
if(clock.length()==0)
{
dlg_snd("Error. There are no clocks available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=clocksmenu();
if(res!="")
{
clocktyp=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this clock to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"clock "+x+" "+y+" "+txt+" "+clocktyp+" "+dmd);
mapper.close();
spawn_clock(x, y, txt, clocktyp, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="cb")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this conveyor belt.");
string mx2=virtual_input_box("","Enter the maximum x of this conveyor belt.");
string my=virtual_input_box("","Enter the minimum y of this conveyor belt.");
string my2=virtual_input_box("","Enter the maximum y of this conveyor belt.");
string dr=virtual_input_box("","Enter the direction of this conveyor belt. 1 for left, 2 for right, 3 for down, and 4 for up.");
string sp=virtual_input_box("","Enter the speed of this conveyor belt.");
if(x=="" and paxx=="" and y=="" and paxy=="" and direction=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
direction=string_to_number(dr);
speedtime=string_to_number(sp);
string[] platform=find_directories("data/sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
string[] belt=find_directories("data/sounds/"+soundpack+"/objects/belts/*");
if(belt.length()==0)
{
dlg_snd("Error. There are no belts available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=beltsmenu();
if(res!="")
{
belttyp=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"belt "+x+" "+paxx+" "+y+" "+paxy+" "+direction+" "+speedtime+" "+tiletype+" "+belttyp);
mapper.close();
spawn_belt(x, paxx, y, paxy, direction, speedtime, tiletype, belttyp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="dlg")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this dialog.");
string mx2=virtual_input_box("","Enter the maximum x of this dialog.");
string my=virtual_input_box("","Enter the minimum y of this dialog.");
string my2=virtual_input_box("","Enter the maximum y of this dialog.");
//input.set_only_allowed_chars("none");
string text=virtual_input_box("","Enter the text of this dialog.");
if(x=="" and paxx=="" and y=="" and paxy=="" and txt=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
txt=text;
string[] dialog=find_directories("data/sounds/"+soundpack+"/objects/dialogs/*");
if(dialog.length()==0)
{
dlg_snd("Error. There are no dialogs available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=dlgsmenu();
if(res!="")
{
dlgtyp=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres25=m.run("Do you want this dialog to auto activate when stepped on?",true);
if(mres25==0)
{
speak("canceled");
return;
}
if(mres25==1)
{
dlt=true;
}
if(mres25==2)
{
dlt=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"dialog "+x+" "+paxx+" "+y+" "+paxy+" "+txt+" "+dlgtyp+" "+dlt);
mapper.close();
spawn_dialog(x, paxx, y, paxy, txt, dlgtyp, dlt);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="ds")
{
//input.set_only_allowed_chars("1234567890-");
string sx=virtual_input_box("","Enter the starting x of this door.");
string sy=virtual_input_box("","Enter the starting y of this door.");
string nx=virtual_input_box("","Enter the finishing x of this door.");
string ny=virtual_input_box("","Enter the finishing y of this door.");
string hp=virtual_input_box("","Enter the health of this door.");
string sp=virtual_input_box("","Enter the speed of this door.");
if(x=="" and y=="" and x2=="" and y2=="" and minhp=="" and speedtime=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
x2=string_to_number(nx);
y2=string_to_number(ny);
minhp=string_to_number(hp);
speedtime=string_to_number(sp);
string[] dloop=find_directories("data/sounds/"+soundpack+"/objects/doors/loop/*");
if(dloop.length()==0)
{
dlg_snd("Error. There are no door loops available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
looptyp=res;
}
}
string[] dmove=find_directories("data/sounds/"+soundpack+"/objects/doors/move/*");
if(dmove.length()==0)
{
dlg_snd("Error. There are no door moves available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res2=dmovesmenu();
if(res2!="")
{
movtyp=res2;
}
}
string[] dopen=find_directories("data/sounds/"+soundpack+"/objects/doors/open/*");
if(dopen.length()==0)
{
dlg_snd("Error. There are no door opens available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res3=dopensmenu();
if(res3!="")
{
opentyp=res3;
}
}
string[] dclose=find_directories("data/sounds/"+soundpack+"/objects/doors/close/*");
if(dclose.length()==0)
{
dlg_snd("Error. There are no door closes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res4=dclosesmenu();
if(res4!="")
{
clostyp=res4;
}
}
string[] desttype=find_directories("data/sounds/"+soundpack+"/objects/doors/dest/*");
if(desttype.length()==0)
{
dlg_snd("Error. There are no door destructions available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res5=destsmenu();
if(res5!="")
{
desttyp=res5;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres27=m.run("Do you want this door to autoactivate when stepped on?",true);
if(mres27==0)
{
speak("canceled");
return;
}
if(mres27==1)
{
dmt=true;
}
if(mres27==2)
{
dmt=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres28=m.run("Do you want this door to be destroyable?",true);
if(mres28==0)
{
speak("canceled");
return;
}
if(mres28==1)
{
dmd=true;
}
if(mres28==2)
{
dmd=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres23=m.run("Would you like to automatically build the opposite side of this door?",true);
if(mres23==0)
{
speak("canceled");
return;
}
if(mres23==1)
{
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"door "+x2+" "+y2+" "+x+" "+y+" "+minhp+" "+speedtime+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_door(x2, y2, x, y, minhp, minhp, speedtime, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(mres23==2)
{
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"door "+x+" "+y+" "+x2+" "+y2+" "+minhp+" "+speedtime+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_door(x, y, x2, y2, minhp, minhp, speedtime, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="ld")
{
//input.set_only_allowed_chars("1234567890-");
string sx=virtual_input_box("","Enter the starting x of this lockable door.");
string sy=virtual_input_box("","Enter the starting y of this lockable door.");
string nx=virtual_input_box("","Enter the finishing x of this lockable door.");
string ny=virtual_input_box("","Enter the finishing y of this lockable door.");
string hp=virtual_input_box("","Enter the health of this lockable door.");
string sp=virtual_input_box("","Enter the speed of this lockable door.");
//input.set_only_allowed_chars("none");
string ps=virtual_input_box("","Enter the password of this lockable door.");
if(x=="" and y=="" and x2=="" and y2=="" and minhp=="" and speedtime=="" and drpassword=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
x2=string_to_number(nx);
y2=string_to_number(ny);
minhp=string_to_number(hp);
speedtime=string_to_number(sp);
drpassword=ps;
string[] dloop=find_directories("data/sounds/"+soundpack+"/objects/doors/loop/*");
if(dloop.length()==0)
{
dlg_snd("Error. There are no door loops available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
looptyp=res;
}
}
string[] dmove=find_directories("data/sounds/"+soundpack+"/objects/doors/move/*");
if(dmove.length()==0)
{
dlg_snd("Error. There are no door moves available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res2=dmovesmenu();
if(res2!="")
{
movtyp=res2;
}
}
string[] dopen=find_directories("data/sounds/"+soundpack+"/objects/doors/open/*");
if(dopen.length()==0)
{
dlg_snd("Error. There are no door opens available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res3=dopensmenu();
if(res3!="")
{
opentyp=res3;
}
}
string[] dclose=find_directories("data/sounds/"+soundpack+"/objects/doors/close/*");
if(dclose.length()==0)
{
dlg_snd("Error. There are no door closes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res4=dclosesmenu();
if(res4!="")
{
clostyp=res4;
}
}
string[] desttype=find_directories("data/sounds/"+soundpack+"/objects/doors/dest/*");
if(desttype.length()==0)
{
dlg_snd("Error. There are no door destructions available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res5=destsmenu();
if(res5!="")
{
desttyp=res5;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres27=m.run("Do you want this lockable door to autoactivate when stepped on?",true);
if(mres27==0)
{
speak("canceled");
return;
}
if(mres27==1)
{
dmt=true;
}
if(mres27==2)
{
dmt=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres28=m.run("Do you want this lockable door to be destroyable?",true);
if(mres28==0)
{
speak("canceled");
return;
}
if(mres28==1)
{
dmd=true;
}
if(mres28==2)
{
dmd=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres23=m.run("Would you like to automatically build the opposite side of this lockable door?",true);
if(mres23==0)
{
speak("canceled");
return;
}
if(mres23==1)
{
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"psdoor "+x2+" "+y2+" "+x+" "+y+" "+minhp+" "+speedtime+" "+drpassword+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_psdoor(x2, y2, x, y, minhp, minhp, speedtime, drpassword, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(mres23==2)
{
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"psdoor "+x+" "+y+" "+x2+" "+y2+" "+minhp+" "+speedtime+" "+drpassword+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_psdoor(x, y, x2, y2, minhp, minhp, speedtime, drpassword, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="psg")
{
//input.set_only_allowed_chars("1234567890-");
string sx=virtual_input_box("","Enter the starting x of this passage.");
string sy=virtual_input_box("","Enter the starting y of this passage.");
string dr=virtual_input_box("","Enter the direction of this passage. 1 for left to right, and 2 for botum to top.");
string lk=virtual_input_box("","Enter the maximum length of this passage.");
string sp=virtual_input_box("","Enter the opening time of this passage.");
if(x=="" and y=="" and direction=="" and ln=="" and speedtime=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
direction=string_to_number(dr);
ln=string_to_number(lk);
speedtime=string_to_number(sp);
string[] platform=find_directories("data/sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
string[] dloop=find_directories("data/sounds/"+soundpack+"/objects/doors/loop/*");
if(dloop.length()==0)
{
dlg_snd("Error. There are no door loops available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
looptyp=res;
}
}
string[] dopen=find_directories("data/sounds/"+soundpack+"/objects/doors/open/*");
if(dopen.length()==0)
{
dlg_snd("Error. There are no door opens available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res2=dopensmenu();
if(res2!="")
{
opentyp=res2;
}
}
string[] dclose=find_directories("data/sounds/"+soundpack+"/objects/doors/close/*");
if(dclose.length()==0)
{
dlg_snd("Error. There are no door closes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res3=dclosesmenu();
if(res3!="")
{
clostyp=res3;
}
}
string sp2=virtual_input_box("","Enter the closing time of this passage.");
if(speedtime2=="")
return;
speedtime2=string_to_number(sp);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"passage "+x+" "+y+" "+direction+" "+ln+" "+speedtime+" "+tiletype+" "+looptyp+" "+opentyp+" "+clostyp+" "+speedtime2);
mapper.close();
spawn_passage(x, y, direction, ln, speedtime, tiletype, looptyp, opentyp, clostyp, speedtime2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="lg")
{
//input.set_only_allowed_chars("1234567890-");
string sx=virtual_input_box("","Enter the starting x of this lockable passage.");
string sy=virtual_input_box("","Enter the starting y of this lockable passage.");
string dr=virtual_input_box("","Enter the direction of this lockable passage. 1 for left to right, and 2 for botum to top.");
string lk=virtual_input_box("","Enter the maximum length of this lockable passage.");
string sp=virtual_input_box("","Enter the opening time of this lockable passage.");
if(x=="" and y=="" and direction=="" and ln=="" and speedtime=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
direction=string_to_number(dr);
ln=string_to_number(lk);
speedtime=string_to_number(sp);
string[] platform=find_directories("data/sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
string[] dloop=find_directories("data/sounds/"+soundpack+"/objects/doors/loop/*");
if(dloop.length()==0)
{
dlg_snd("Error. There are no door loops available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
looptyp=res;
}
}
string[] dopen=find_directories("data/sounds/"+soundpack+"/objects/doors/open/*");
if(dopen.length()==0)
{
dlg_snd("Error. There are no door opens available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res2=dopensmenu();
if(res2!="")
{
opentyp=res2;
}
}
string[] dclose=find_directories("data/sounds/"+soundpack+"/objects/doors/close/*");
if(dclose.length()==0)
{
dlg_snd("Error. There are no door closes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res3=dclosesmenu();
if(res3!="")
{
clostyp=res3;
}
}
//input.set_only_allowed_chars("none");
string ps=virtual_input_box("","Enter the password of this lockable passage.");
string sp2=virtual_input_box("","Enter the closing time of this lockable passage.");
if(pspassword=="" and speedtime2=="")
return;
pspassword=ps;
speedtime2=string_to_number(sp);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"pspassage "+x+" "+y+" "+direction+" "+ln+" "+speedtime+" "+tiletype+" "+looptyp+" "+opentyp+" "+clostyp+" "+pspassword+" "+speedtime2);
mapper.close();
spawn_pspassage(x, y, direction, ln, speedtime, tiletype, looptyp, opentyp, clostyp, pspassword, speedtime2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="em")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this enemy.");
string my=virtual_input_box("","Enter the y of this enemy.");
string rng=virtual_input_box("","Enter the horizontal attack range of this enemy.");
string rng2=virtual_input_box("","Enter the vertical attack range of this enemy.");
string rng3=virtual_input_box("","Enter the horizontal seeing range of this enemy.");
string rng4=virtual_input_box("","Enter the vertical seeing range of this enemy.");
string hp=virtual_input_box("","Enter the health of this enemy.");
string hc=virtual_input_box("","Enter the maximum lives of this enemy.");
string dm=virtual_input_box("","Enter the maximum damage of this enemy.");
string ft=virtual_input_box("","Enter the fire time of this enemy.");
string sp=virtual_input_box("","Enter the speed of this enemy.");
string lev=virtual_input_box("","Enter the level of this enemy.");
string exper=virtual_input_box("","Enter the xp of this enemy.");
if(x=="" and y=="" and emrange=="" and emrange2=="" and emrange3=="" and emrange4=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
emrange=string_to_number(rng);
emrange2=string_to_number(rng2);
emrange3=string_to_number(rng3);
emrange4=string_to_number(rng4);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] enemie=find_directories("data/sounds/"+soundpack+"/npc/normal/enemies/*");
if(enemie.length()==0)
{
dlg_snd("Error. There are no enemies available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=enemiesmenu();
if(res!="")
{
emtype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the enemy attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the enemy move?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the enemy folow you up on other platforms?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres5=m.run("Should the enemy drop an item after killing it?",true);
if(mres5==0)
{
speak("canceled");
return;
}
if(mres5==1)
{
itms=true;
}
if(mres5==2)
{
itms=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"enemie "+x+" "+y+" "+emrange+" "+emrange2+" "+emrange3+" "+emrange4+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+emtype+" "+fb+" "+mb+" "+mb2+" "+itms);
mapper.close();
spawn_enemie(x, y, emrange, emrange2, emrange3, emrange4, minhp, minhp, card, damage, firetime, speedtime, lv, xn, emtype, fb, mb, mb2, itms);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="ez")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this enemy zone.");
string mx2=virtual_input_box("","Enter the maximum x of this enemy zone.");
string my=virtual_input_box("","Enter the y of this enemy zone.");
string sp=virtual_input_box("","Enter the spawn time of this enemy zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] enemie=find_directories("data/sounds/"+soundpack+"/npc/normal/enemies/*");
if(enemie.length()==0)
{
dlg_snd("Error. There are no enemies available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=enemiesmenu(true);
if(res!="")
{
emtype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"enemie_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+emtype);
mapper.close();
spawn_enemiezone(x, paxx, y, speedtime, emtype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="fbr")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this floor breaker.");
string my=virtual_input_box("","Enter the y of this floor breaker.");
if(x=="" and y=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
string[] floorbtype=find_directories("data/sounds/"+soundpack+"/objects/floor breakers/*");
if(floorbtype.length()==0)
{
dlg_snd("Error. There are no floor breakers available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=floorsmenu();
if(res!="")
{
floortyp=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"floor_breaker "+x+" "+y+" "+floortyp);
mapper.close();
spawn_floorbreaker(x, y, floortyp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="fld")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this force field.");
string mx2=virtual_input_box("","Enter the maximum x of this force field.");
string my=virtual_input_box("","Enter the minimum y of this force field.");
string my2=virtual_input_box("","Enter the maximum y of this force field.");
string dm=virtual_input_box("","Enter the maximum damage of this force field.");
string sp=virtual_input_box("","Enter the speed of this force field.");
if(x=="" and paxx=="" and y=="" and paxy=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
string[] forcefield=find_directories("data/sounds/"+soundpack+"/objects/force fields/*");
if(forcefield.length()==0)
{
dlg_snd("Error. There are no force fields available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=forcesmenu();
if(res!="")
{
forcetyp=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"forcefield "+x+" "+paxx+" "+y+" "+paxy+" "+damage+" "+speedtime+" "+forcetyp);
mapper.close();
spawn_forcefield(x, paxx, y, paxy, damage, speedtime, forcetyp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="hd")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this hazard.");
string mx2=virtual_input_box("","Enter the maximum x of this hazard.");
string my=virtual_input_box("","Enter the minimum y of this hazard.");
string my2=virtual_input_box("","Enter the maximum y of this hazard.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] hazardtype=find_directories("data/sounds/"+soundpack+"/objects/hazards/*");
if(hazardtype.length()==0)
{
dlg_snd("Error. There are no hazards available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=hazardsmenu();
if(res!="")
{
hazztype=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Would you like to automaticly spawn ledges on both sides of this hazard?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
lp=true;
}
if(mres==2)
{
lp=false;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"hazard "+x+" "+paxx+" "+y+" "+paxy+" "+hazztype+" "+lp);
mapper.close();
spawn_hazard(x, paxx, y, paxy, hazztype, lp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="hz")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this heal zone.");
string mx2=virtual_input_box("","Enter the maximum x of this heal zone.");
string my=virtual_input_box("","Enter the minimum y of this heal zone.");
string my2=virtual_input_box("","Enter the maximum y of this heal zone.");
string hm=virtual_input_box("","Enter the healing mode of this heal zone. 0 for decreasing health, and 1 for increasing health.");
string hp=virtual_input_box("","Enter the health of this heal zone.");
string ht=virtual_input_box("","Enter the healing time of this heal zone.");
if(x=="" and paxx=="" and y=="" and paxy=="" and healthmode=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
healthmode=string_to_number(hm);
damage=string_to_number(hp);
speedtime=string_to_number(ht);
string[] heals=find_directories("data/sounds/"+soundpack+"/objects/heal zones/*");
if(heals.length()==0)
{
dlg_snd("Error. There are no heal zones available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=healsmenu();
if(res!="")
{
healtyp=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"heal_zone "+x+" "+paxx+" "+y+" "+paxy+" "+healthmode+" "+damage+" "+speedtime+" "+healtyp);
mapper.close();
spawn_healzone(x, paxx, y, paxy, healthmode, damage, speedtime, healtype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="mn")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this mine.");
string my=virtual_input_box("","Enter the y of this mine.");
string dm=virtual_input_box("","Enter the maximum damage of this mine.");
if(x=="" and y=="" and damage=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
damage=string_to_number(dm);
string[] mine=find_directories("data/sounds/"+soundpack+"/objects/mines/*");
if(mine.length()==0)
{
dlg_snd("Error. There are no mines available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=minesmenu();
if(res!="")
{
minetyp=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Should this mine be auto activated?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
trg=true;
}
if(mres==2)
{
trg=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"mine "+x+" "+y+" "+damage+" "+minetyp+" "+trg);
mapper.close();
spawn_mine(x, y, damage, minetyp, trg);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="mhd")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the left x of this moving hazard.");
string mx2=virtual_input_box("","Enter the right x of this moving hazard.");
string my=virtual_input_box("","Enter the botum y of this moving hazard.");
string my2=virtual_input_box("","Enter the top y of this moving hazard.");
string sx=virtual_input_box("","Enter the maximum x length of this moving hazard.");
string sy=virtual_input_box("","Enter the maximum y length of this moving hazard.");
string dr=virtual_input_box("","Enter the direction of this moving hazard. 0 for Right and left, 1 for up and down, 2 for Diagonal up/right and down/left, 3 for diagonal up/left and down/right, 4 for Left and right, 5 for Down and up, 6 for Diagonal down/left and up/right, and 7 for diagonal down/right and up/left.");
string sn=virtual_input_box("","Enter the snap mode of this moving hazard. 0 for no snapping, 1 for forward to snap, 2 for backward to snap, and 3 for snap at ends.");
string sp=virtual_input_box("","Enter the sspeed of this moving hazard. 100 is equaled to 1000 milliseconds, 50 is equaled to 500 milliseconds, 10 is equaled to 100 milliseconds, 5 is equaled to 50 milliseconds, and 1 is equaled to 10 milliseconds.");
if(x=="" and paxx=="" and y=="" and paxy=="" and x2=="" and y2=="" and direction=="" and direction2=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
x2=string_to_number(sx);
y2=string_to_number(sy);
direction=string_to_number(dr);
direction2=string_to_number(sn);
speedtime=string_to_number(sp);
string[] hazardtype=find_directories("data/sounds/"+soundpack+"/objects/hazards/*");
if(hazardtype.length()==0)
{
dlg_snd("Error. There are no hazards available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=hazardsmenu();
if(res!="")
{
hazztype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"mhazard "+x+" "+paxx+" "+y+" "+paxy+" "+x2+" "+y2+" "+direction+" "+direction2+" "+speedtime+" "+hazztype);
mapper.close();
spawn_moving_hazard(x, paxx, y, paxy, x2, y2, direction, direction2, speedtime, hazztype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="mpl")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the left x of this moving platform.");
string mx2=virtual_input_box("","Enter the right x of this moving platform.");
string my=virtual_input_box("","Enter the botum y of this moving platform.");
string my2=virtual_input_box("","Enter the top y of this moving platform.");
string sx=virtual_input_box("","Enter the maximum x length of this moving platform.");
string dr=virtual_input_box("","Enter the direction of this moving platform. 0 for Right and left, 1 for up and down, 2 for Diagonal up/right and down/left, 3 for diagonal up/left and down/right, 4 for Left and right, 5 for Down and up, 6 for Diagonal down/left and up/right, and 7 for diagonal down/right and up/left.");
string sn=virtual_input_box("","Enter the snap mode of this moving platform. 0 for no snapping, 1 for forward to snap, 2 for backward to snap, and 3 for snap at ends.");
string sp=virtual_input_box("","Enter the sspeed of this moving platform. 100 is equaled to 1000 milliseconds, 50 is equaled to 500 milliseconds, 10 is equaled to 100 milliseconds, 5 is equaled to 50 milliseconds, and 1 is equaled to 10 milliseconds.");
if(x=="" and paxx=="" and y=="" and paxy=="" and x2=="" and direction=="" and direction2=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
x2=string_to_number(sx);
direction=string_to_number(dr);
direction2=string_to_number(sn);
speedtime=string_to_number(sp);
string[] platform=find_directories("data/sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
string[] mplatform=find_directories("data/sounds/"+soundpack+"/objects/moving platforms/*");
if(mplatform.length()==0)
{
dlg_snd("Error. There are no moving platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=mplatsmenu();
if(res!="")
{
mplattyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres2= s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres2==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume2=s.get_item_value(0);
pitch2=s.get_item_value(1);
//input.set_only_allowed_chars("1234567890-");
string vof=virtual_input_box("","Enter the volume offset of this moving platform.");
if(volset=="")
return;
volset=string_to_number(vof);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"mplatform "+x+" "+paxx+" "+y+" "+paxy+" "+x2+" "+direction+" "+direction2+" "+speedtime+" "+tiletype+" "+volume+" "+pitch+" "+mplattyp+" "+volume2+" "+pitch2+" "+volset);
mapper.close();
spawn_moving_platform(x, paxx, y, paxy, x2, direction, direction2, speedtime, tiletype, volume, pitch, mplattyp, volume2, pitch2, volset);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="cp")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this checkpoint.");
string my=virtual_input_box("","Enter the y of this checkpoint.");
string sp=virtual_input_box("","Enter the speed of this checkpoint. Press enter to use the default speed, or control backspace to clear the input to type your own speed.", "350");
if(x=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] checktype=find_directories("data/sounds/"+soundpack+"/objects/checkpoints/*");
if(checktype.length()==0)
{
dlg_snd("Error. There are no checkpoints available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=checksmenu();
if(res!="")
{
checktyp=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"checkpoint "+x+" "+y+" "+speedtime+" "+checktyp);
mapper.close();
spawn_checkpoint(x, y, speedtime, checktyp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="obj")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this item.");
string my=virtual_input_box("","Enter the y of this item.");
string sp=virtual_input_box("","Enter the speed of this item. Press enter to use the default speed, or control backspace to clear the input to type your own speed.", "500");
if(x=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
speedtime=string_to_number(sp);
setupmenu();
m.add_item_tts("health", "hp");
m.add_item_tts("other", "ot");
int mres=m.run("Items menu",true);
string itsm=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
return;
}
if(itsm=="hp")
{
string[] ithealth=find_directories("data/sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(ithealth.length()==0)
{
dlg_snd("Error. There are no health items available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=healthsmenu();
if(res!="")
{
itemtype="health";
itemtype2=res;
}
}
}
if(itsm=="ot")
{
string[] itother=find_directories("data/sounds/"+soundpack+"/equipments/items/unsorted/other/*");
if(itother.length()==0)
{
dlg_snd("Error. There are no other items available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=othersmenu();
if(res!="")
{
itemtype="other";
itemtype2=res;
}
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres28=m.run("Do you want this item to be autograbbed when stepped on?",true);
if(mres28==0)
{
speak("canceled");
return;
}
if(mres28==1)
{
itm=true;
}
if(mres28==2)
{
itm=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"item "+x+" "+y+" "+speedtime+" "+itemtype+" "+itemtype2+" "+itm);
mapper.close();
spawn_obj(x, y, speedtime, itemtype, itemtype2, itm);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="iz")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this item zone.");
string mx2=virtual_input_box("","Enter the maximum x of this item zone.");
string my=virtual_input_box("","Enter the minimum y of this item zone.");
string my2=virtual_input_box("","Enter the maximum y of this item zone.");
string sp=virtual_input_box("","Enter the spawn time of this item zone.");
if(x=="" and paxx=="" and y=="" and paxy=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
speedtime=string_to_number(sp);
setupmenu();
m.add_item_tts("health", "hp");
m.add_item_tts("other", "ot");
int mres=m.run("Items menu",true);
string itsm=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
return;
}
if(itsm=="hp")
{
string[] ithealth=find_directories("data/sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(ithealth.length()==0)
{
dlg_snd("Error. There are no health items available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=healthsmenu();
if(res!="")
{
itemtype="health";
itemtype2=res;
}
}
}
if(itsm=="ot")
{
string[] itother=find_directories("data/sounds/"+soundpack+"/equipments/items/unsorted/other/*");
if(itother.length()==0)
{
dlg_snd("Error. There are no other items available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=othersmenu();
if(res!="")
{
itemtype="other";
itemtype2=res;
}
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"item_zone "+x+" "+paxx+" "+y+" "+paxy+" "+speedtime+" "+itemtype+" "+itemtype2);
mapper.close();
spawn_objzone(x, paxx, y, paxy, speedtime, itemtype, itemtype2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="lf")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this lift.");
string mx2=virtual_input_box("","Enter the maximum x of this lift.");
string my=virtual_input_box("","Enter the minimum y of this lift.");
string my2=virtual_input_box("","Enter the maximum y of this lift.");
string dr=virtual_input_box("","Enter the direction of this lift. 0 for down and up, and 1 for up and down.");
string sp=virtual_input_box("","Enter the speed of this lift.");
if(x=="" and paxx=="" and y=="" and paxy=="" and direction=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
direction=string_to_number(dr);
speedtime=string_to_number(sp);
string[] platform=find_directories("data/sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
string[] liftform=find_directories("data/sounds/"+soundpack+"/objects/lifts/*");
if(liftform.length()==0)
{
dlg_snd("Error. There are no lifts available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=liftsmenu();
if(res!="")
{
lifttyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres2= s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres2==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume2=s.get_item_value(0);
pitch2=s.get_item_value(1);
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"lift "+x+" "+paxx+" "+y+" "+paxy+" "+direction+" "+speedtime+" "+tiletype+" "+volume+" "+pitch+" "+lifttyp+" "+volume2+" "+pitch2);
mapper.close();
spawn_lift(x, paxx, y, paxy, direction, speedtime, tiletype, volume, pitch, lifttyp, volume2, pitch2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="mus")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this music source.");
string mx2=virtual_input_box("","Enter the maximum x of this music source.");
string my=virtual_input_box("","Enter the minimum y of this music source.");
string my2=virtual_input_box("","Enter the maximum y of this music source.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] music=find_directories("data/sounds/"+soundpack+"/objects/musics/*");
if(music.length()==0)
{
dlg_snd("Error. There are no music sources available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=musicsmenu();
if(res!="")
{
mustyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"music_source "+x+" "+paxx+" "+y+" "+paxy+" "+mustyp+" "+volume+" "+pitch);
mapper.close();
spawn_musicsource(x, paxx, y, paxy, mustyp, volume, pitch);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="pf")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this platform.");
string mx2=virtual_input_box("","Enter the maximum x of this platform.");
string my=virtual_input_box("","Enter the y of this platform.");
if(x=="" and paxx=="" and y=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
string[] platform=find_directories("data/sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
//input.set_only_allowed_chars("1234567890-");
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"platform "+x+" "+paxx+" "+y+" "+tiletype+" "+volume+" "+pitch);
mapper.close();
spawn_platform(x, paxx, y, y, tiletype, volume, pitch);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="pj")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this projectile.");
string my=virtual_input_box("","Enter the y of this projectile.");
string dr=virtual_input_box("","Enter the direction of this projectile. 0 for left, and 1 for right");
string hp=virtual_input_box("","Enter the health of this projectile.");
string hc=virtual_input_box("","Enter the maximum lives of this projectile.");
string dm=virtual_input_box("","Enter the maximum damage of this projectile.");
string sp=virtual_input_box("","Enter the speed of this projectile.");
string lev=virtual_input_box("","Enter the level of this projectile.");
string exper=virtual_input_box("","Enter the xp of this projectile.");
if(x=="" and y=="" and direction=="" and minhp=="" and card=="" and damage=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
direction=string_to_number(dr);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] projectile=find_directories("data/sounds/"+soundpack+"/npc/normal/projectiles/*");
if(projectile.length()==0)
{
dlg_snd("Error. There are no projectiles available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=projesmenu();
if(res!="")
{
potype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres8=m.run("Should the projectile attack you?",true);
if(mres8==0)
{
speak("canceled");
return;
}
if(mres8==1)
{
fb=true;
}
if(mres8==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres9=m.run("Should the projectile move?",true);
if(mres9==0)
{
speak("canceled");
return;
}
if(mres9==1)
{
mb=true;
}
if(mres9==2)
{
mb=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"projectile "+x+" "+y+" "+direction+" "+minhp+" "+card+" "+damage+" "+speedtime+" "+lv+" "+xn+" "+potype+" "+fb+" "+mb);
mapper.close();
spawn_projectile(x, y, direction, minhp, minhp, card, damage, speedtime, lv, xn, potype, fb, mb);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="pz")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this projectile zone.");
string mx2=virtual_input_box("","Enter the maximum x of this projectile zone.");
string my=virtual_input_box("","Enter the y of this projectile zone.");
string sp=virtual_input_box("","Enter the spawn time of this projectile zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] projectile=find_directories("data/sounds/"+soundpack+"/npc/normal/projectiles/*");
if(projectile.length()==0)
{
dlg_snd("Error. There are no projectiles available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=projesmenu(true);
if(res!="")
{
potype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"projectile_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+potype);
mapper.close();
spawn_projzone(x, paxx, y, speedtime, potype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="rev")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this reverb.");
string mx2=virtual_input_box("","Enter the maximum x of this reverb.");
string my=virtual_input_box("","Enter the minimum y of this reverb.");
string my2=virtual_input_box("","Enter the maximum y of this reverb.");
//input.set_only_allowed_chars("none");
string rd=virtual_input_box("","Enter the id of this reverb. Press enter to use a random reverb id, or control backspace to clear the input to type your own reverb id.", generate_custom_token(random(5, 10), "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"));
if(x=="" and paxx=="" and y=="" and paxy=="" and reverid=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
reverid=rd;
create_slider();
s.add_slider_item("dry_mix", 0.0, 1.0, 0.0, 0.1);
s.add_slider_item("wet_mix", 0.0, 1.0, 0.0, 0.1);
s.add_slider_item("room_size", 0.0, 1.0, 0.0, 0.1);
s.add_slider_item("damping", 0.0, 1.0, 0.0, 0.1);
s.add_slider_item("width", 0.0, 1.0, 0.0, 0.1);
int sres = s.run_slider("Reverb designer. Press tab or shift tab to cycle through the reverb parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
revdry=s.get_item_value(0);
revwet=s.get_item_value(1);
revsize=s.get_item_value(2);
revdamp=s.get_item_value(3);
revwidth=s.get_item_value(4);
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"reverb "+x+" "+paxx+" "+y+" "+paxy+" "+reverid+" "+revdry+" "+revwet+" "+revsize+" "+revdamp+" "+revwidth);
mapper.close();
spawn_reverb_effect(x, paxx, y, paxy, reverid, revdry, revwet, revsize, revdamp, revwidth);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="rt")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this robot.");
string my=virtual_input_box("","Enter the y of this robot.");
string rng=virtual_input_box("","Enter the horizontal attack range of this robot.");
string rng2=virtual_input_box("","Enter the vertical attack range of this robot.");
string rng3=virtual_input_box("","Enter the horizontal seeing range of this robot.");
string rng4=virtual_input_box("","Enter the vertical seeing range of this robot.");
string hp=virtual_input_box("","Enter the health of this robot.");
string hc=virtual_input_box("","Enter the maximum lives of this robot.");
string dm=virtual_input_box("","Enter the maximum damage of this robot.");
string ft=virtual_input_box("","Enter the fire time of this robot.");
string sp=virtual_input_box("","Enter the speed of this robot.");
string lev=virtual_input_box("","Enter the level of this robot.");
string exper=virtual_input_box("","Enter the xp of this robot.");
if(x=="" and y=="" and robrange=="" and robrange2=="" and robrange3=="" and robrange4=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
robrange=string_to_number(rng);
robrange2=string_to_number(rng2);
robrange3=string_to_number(rng3);
robrange4=string_to_number(rng4);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] robot=find_directories("data/sounds/"+soundpack+"/npc/normal/robots/*");
if(robot.length()==0)
{
dlg_snd("Error. There are no robots available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=robotsmenu();
if(res!="")
{
rotype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the robot attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the robot move?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the robot folow you up on other platforms?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres5=m.run("Should the robot drop an item after killing it?",true);
if(mres5==0)
{
speak("canceled");
return;
}
if(mres5==1)
{
itms=true;
}
if(mres5==2)
{
itms=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"robot "+x+" "+y+" "+robrange+" "+robrange2+" "+robrange3+" "+robrange4+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+rotype+" "+fb+" "+mb+" "+mb2+" "+itms);
mapper.close();
spawn_robot(x, y, robrange, robrange2, robrange3, robrange4, minhp, minhp, card, damage, firetime, speedtime, lv, xn, rotype, fb, mb, mb2, itms);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="rz")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this robot zone.");
string mx2=virtual_input_box("","Enter the maximum x of this robot zone.");
string my=virtual_input_box("","Enter the y of this robot zone.");
string sp=virtual_input_box("","Enter the spawn time of this robot zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] robot=find_directories("data/sounds/"+soundpack+"/npc/normal/robots/*");
if(robot.length()==0)
{
dlg_snd("Error. There are no robots available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=robotsmenu(true);
if(res!="")
{
rotype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"robot_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+rotype);
mapper.close();
spawn_robotzone(x, paxx, y, speedtime, rotype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="sn")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this sign.");
string my=virtual_input_box("","Enter the y of this sign.");
//input.set_only_allowed_chars("none");
string text=virtual_input_box("","Enter the text of this sign.");
if(x=="" and y=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
txt=text;
string[] signs=find_directories("data/sounds/"+soundpack+"/objects/signs/*");
if(signs.length()==0)
{
dlg_snd("Error. There are no signs available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=signsmenu();
if(res!="")
{
signtyp=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this sign to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Would you like the sign sound to be looped?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
lpg=true;
}
if(mres==2)
{
lpg=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"sign "+x+" "+y+" "+txt+" "+signtyp+" "+dmd+" "+lpg);
mapper.close();
spawn_sign(x, y, txt, signtyp, dmd, lpg);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="src")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this sound source.");
string mx2=virtual_input_box("","Enter the maximum x of this sound source.");
string my=virtual_input_box("","Enter the minimum y of this sound source.");
string my2=virtual_input_box("","Enter the maximum y of this sound source.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] source=find_directories("data/sounds/"+soundpack+"/objects/sources/*");
if(source.length()==0)
{
dlg_snd("Error. There are no sources available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=sorcesmenu();
if(res!="")
{
sorcetyp=res;
}
}
//input.set_only_allowed_chars("1234567890-");
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"sound_source "+x+" "+paxx+" "+y+" "+paxy+" "+sorcetyp+" "+volume+" "+pitch);
mapper.close();
spawn_soundsource(x, paxx, y, paxy, sorcetyp, volume, pitch);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="sp")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this spike.");
string mx2=virtual_input_box("","Enter the maximum x of this spike.");
string my=virtual_input_box("","Enter the minimum y of this spike.");
string my2=virtual_input_box("","Enter the maximum y of this spike.");
string hp=virtual_input_box("","Enter the health of this spike.");
string dm=virtual_input_box("","Enter the maximum damage of this spike.");
string sp=virtual_input_box("","Enter the speed of this spike.");
if(x=="" and paxx=="" and y=="" and paxy=="" and minhp=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
minhp=string_to_number(hp);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
string[] spike=find_directories("data/sounds/"+soundpack+"/objects/spikes/*");
if(spike.length()==0)
{
dlg_snd("Error. There are no spikes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=spikesmenu();
if(res!="")
{
spiktype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this spike to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"spike "+x+" "+paxx+" "+y+" "+paxy+" "+minhp+" "+damage+" "+speedtime+" "+spiktype+" "+dmd);
mapper.close();
spawn_spike(x, paxx, y, paxy, minhp, minhp, damage, speedtime, spiktype, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="st")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this spawnpoint.");
string my=virtual_input_box("","Enter the y of this spawnpoint.");
if(x=="" and y=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"spawnpoint "+x+" "+y);
mapper.close();
create_spawnpoint(x, y);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="sf")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this staircase.");
string mx2=virtual_input_box("","Enter the maximum x of this staircase.");
string my=virtual_input_box("","Enter the minimum y of this staircase.");
string my2=virtual_input_box("","Enter the maximum y of this staircase.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] platform=find_directories("data/sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"staircase "+x+" "+paxx+" "+y+" "+paxy+" "+tiletype+" "+volume+" "+pitch);
mapper.close();
spawn_staircase(x, paxx, y, paxy, tiletype, volume, pitch);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="tp")
{
//input.set_only_allowed_chars("1234567890-");
string sx=virtual_input_box("","Enter the starting x of this teleporter.");
string sy=virtual_input_box("","Enter the starting y of this teleporter.");
string nx=virtual_input_box("","Enter the finishing x of this teleporter.");
string ny=virtual_input_box("","Enter the finishing y of this teleporter.");
string rng=virtual_input_box("","Enter the horizontal seeing range of this teleporter.");
string rng2=virtual_input_box("","Enter the vertical seeing range of this teleporter.");
string sp=virtual_input_box("","Enter the speed of this teleporter.");
if(x=="" and y=="" and x2=="" and y2=="" and telrange=="" and telrange2=="" and speedtime=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
x2=string_to_number(nx);
y2=string_to_number(ny);
telrange=string_to_number(rng);
telrange2=string_to_number(rng2);
speedtime=string_to_number(sp);
string[] teleporter=find_directories("data/sounds/"+soundpack+"/objects/teleporters/*");
if(teleporter.length()==0)
{
dlg_snd("Error. There are no teleporters available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=teleportersmenu();
if(res!="")
{
teltype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres16=m.run("Should the teleporter move?",true);
if(mres16==0)
{
speak("canceled");
return;
}
if(mres16==1)
{
mb=true;
}
if(mres16==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres17=m.run("Should the teleporter folow you up on other platforms?",true);
if(mres17==0)
{
speak("canceled");
return;
}
if(mres17==1)
{
mb2=true;
}
if(mres17==2)
{
mb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres18=m.run("Should this teleporter be single-use only?",true);
if(mres18==0)
{
speak("canceled");
return;
}
if(mres18==1)
{
sse=true;
}
if(mres18==2)
{
sse=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"teleporter "+x+" "+y+" "+x2+" "+y2+" "+telrange+" "+telrange2+" "+speedtime+" "+teltype+" "+mb+" "+mb2+" "+sse);
mapper.close();
spawn_teleporter(x, y, x2, y2, telrange, telrange2, speedtime, teltype, mb, mb2, sse);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="txt")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this text square.");
string my=virtual_input_box("","Enter the y of this text square.");
//input.set_only_allowed_chars("none");
string text=virtual_input_box("","Enter the text of this text square.");
if(x=="" and y=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
txt=text;
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"text_square "+x+" "+y+" "+txt);
mapper.close();
spawn_text_square(x, y, txt);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="tbm")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this time bomb.");
string my=virtual_input_box("","Enter the y of this time bomb.");
string dm=virtual_input_box("","Enter the maximum damage of this time bomb.");
string sp=virtual_input_box("","Enter the speed of this time bomb.");
if(x=="" and y=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
string[] timebomb=find_directories("data/sounds/"+soundpack+"/objects/time bombs/*");
if(timebomb.length()==0)
{
dlg_snd("Error. There are no time bombs available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=timbombsmenu();
if(res!="")
{
timbotype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"timebomb "+x+" "+y+" "+damage+" "+speedtime+" "+timbotype);
mapper.close();
spawn_timebomb(x, y, damage, speedtime, timbotype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="trc")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this timed source.");
string mx2=virtual_input_box("","Enter the maximum x of this timed source.");
string my=virtual_input_box("","Enter the minimum y of this timed source.");
string my2=virtual_input_box("","Enter the maximum y of this timed source.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] source=find_directories("data/sounds/"+soundpack+"/objects/sources/*");
if(source.length()==0)
{
dlg_snd("Error. There are no sources available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=sorcesmenu();
if(res!="")
{
sorcetyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
//input.set_only_allowed_chars("1234567890-");
string sp=virtual_input_box("","Enter the speed of this timed source.");
if(speedtime=="")
return;
speedtime=string_to_number(sp);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"timed_source "+x+" "+paxx+" "+y+" "+paxy+" "+sorcetyp+" "+volume+" "+pitch+" "+speedtime);
mapper.close();
spawn_timedsource(x, paxx, y, paxy, volume, pitch, speedtime, sorcetyp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="tmc")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this timed music.");
string mx2=virtual_input_box("","Enter the maximum x of this timed music.");
string my=virtual_input_box("","Enter the minimum y of this timed music.");
string my2=virtual_input_box("","Enter the maximum y of this timed music.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] music=find_directories("data/sounds/"+soundpack+"/objects/musics/*");
if(music.length()==0)
{
dlg_snd("Error. There are no musics available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=musicsmenu();
if(res!="")
{
mustyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
//input.set_only_allowed_chars("1234567890-");
string sp=virtual_input_box("","Enter the speed of this timed music.");
if(speedtime=="")
return;
speedtime=string_to_number(sp);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"timed_music "+x+" "+paxx+" "+y+" "+paxy+" "+mustyp+" "+volume+" "+pitch+" "+speedtime);
mapper.close();
spawn_timedmusic(x, paxx, y, paxy, volume, pitch, speedtime, mustyp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="tmt")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this timed text.");
string mx2=virtual_input_box("","Enter the maximum x of this timed text.");
string my=virtual_input_box("","Enter the minimum y of this timed text.");
string my2=virtual_input_box("","Enter the maximum y of this timed text.");
string sp=virtual_input_box("","Enter the speed of this timed text.");
//input.set_only_allowed_chars("none");
string text=virtual_input_box("","Enter the text of this timed text.");
if(x=="" and paxx=="" and y=="" and paxy=="" and speedtime=="" and txt=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
speedtime=string_to_number(sp);
txt=text;
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"timed_text "+x+" "+paxx+" "+y+" "+paxy+" "+speedtime+" "+txt);
mapper.close();
spawn_timedtext(x, paxx, y, paxy, speedtime, txt);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="trp")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this travelpoint.");
string mx2=virtual_input_box("","Enter the maximum x of this travelpoint.");
string my=virtual_input_box("","Enter the minimum y of this travelpoint.");
string my2=virtual_input_box("","Enter the maximum y of this travelpoint.");
//input.set_only_allowed_chars("none");
string mtext=virtual_input_box("","Enter the destenation map of this travelpoint.");
//input.set_only_allowed_chars("1234567890-");
string dx=virtual_input_box("","Enter the destenation x of this travelpoint.");
string dy=virtual_input_box("","Enter the destenation y of this travelpoint.");
//input.set_only_allowed_chars("none");
string dtext=virtual_input_box("","Enter the destenation text of this travelpoint.");
if(x=="" and paxx=="" and y=="" and paxy=="" and txt=="" and x2=="" and y2=="" and txt2=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
txt=mtext;
x2=string_to_number(dx);
y2=string_to_number(dy);
txt2=dtext;
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Would you like to automatically build the opposite side of this travelpoint?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
string mtext2=virtual_input_box("","Enter the destenation map of this travelpoint to go back to.");
if(txt=="")
return;
txt=mtext2;
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"travelpoint "+x+" "+paxx+" "+y+" "+paxy+" "+txt+" "+y2+" "+x2+" "+txt2);
mapper.close();
spawn_travelpoint(x, paxx, y, paxy, txt, y2, x2, txt2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(mres==2)
{
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"travelpoint "+x+" "+paxx+" "+y+" "+paxy+" "+txt+" "+x2+" "+y2+" "+txt2);
mapper.close();
spawn_travelpoint(x, paxx, y, paxy, txt, x2, y2, txt2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="tt")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this turret.");
string my=virtual_input_box("","Enter the y of this turret.");
string hp=virtual_input_box("","Enter the health of this turret.");
string hc=virtual_input_box("","Enter the maximum lives of this turret.");
string dm=virtual_input_box("","Enter the maximum damage of this turret.");
string ft=virtual_input_box("","Enter the fire time of this turret.");
string lt=virtual_input_box("","Enter the launch time of this turret.");
string sp=virtual_input_box("","Enter the speed of this turret.");
string lev=virtual_input_box("","Enter the level of this turret.");
string exper=virtual_input_box("","Enter the xp of this turret.");
if(x=="" and y=="" and minhp=="" and card=="" and damage=="" and firetime=="" and launchtime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
launchtime=string_to_number(lt);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] turret=find_directories("data/sounds/"+soundpack+"/npc/normal/turrets/*");
if(turret.length()==0)
{
dlg_snd("Error. There are no turrets available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=turretsmenu();
if(res!="")
{
tutype=res;
}
}
setupmenu();
m.add_item_tts("animal","an2");
m.add_item_tts("enemie","em2");
m.add_item_tts("projectile","pj2");
m.add_item_tts("robot","rt2");
m.add_item_tts("zombie","zb2");
int mres=m.run("What would you like this turret to spawn?",true);
string buildem2=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
return;
}
if(buildem2=="an2")
{
string[] animal=find_directories("data/sounds/"+soundpack+"/npc/normal/animals/*");
if(animal.length()==0)
{
dlg_snd("Error. There are no animals available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=animalsmenu();
if(res!="")
{
tutype2="animal";
tutype3=res;
}
}
}
if(buildem2=="em2")
{
string[] enemie=find_directories("data/sounds/"+soundpack+"/npc/normal/enemies/*");
if(enemie.length()==0)
{
dlg_snd("Error. There are no enemies available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=enemiesmenu();
if(res!="")
{
tutype2="enemie";
tutype3=res;
}
}
}
if(buildem2=="pj2")
{
string[] projectile=find_directories("data/sounds/"+soundpack+"/npc/normal/projectiles/*");
if(projectile.length()==0)
{
dlg_snd("Error. There are no projectiles available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=projesmenu();
if(res!="")
{
tutype2="projectile";
tutype3=res;
}
}
}
if(buildem2=="rt2")
{
string[] robot=find_directories("data/sounds/"+soundpack+"/npc/normal/robots/*");
if(robot.length()==0)
{
dlg_snd("Error. There are no robots available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=robotsmenu();
if(res!="")
{
tutype2="robot";
tutype3=res;
}
}
}
if(buildem2=="zb2")
{
string[] zombie=find_directories("data/sounds/"+soundpack+"/npc/normal/zombies/*");
if(zombie.length()==0)
{
dlg_snd("Error. There are no zombies available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=zombiesmenu();
if(res!="")
{
tutype2="zombie";
tutype3=res;
}
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres18=m.run("Should the turret attack you?",true);
if(mres18==0)
{
speak("canceled");
return;
}
if(mres18==1)
{
fb=true;
}
if(mres18==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres19=m.run("Should the turret move?",true);
if(mres19==0)
{
speak("canceled");
return;
}
if(mres19==1)
{
mb=true;
}
if(mres19==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres20=m.run("Should the turret folow you up on other platforms?",true);
if(mres20==0)
{
speak("canceled");
return;
}
if(mres20==1)
{
mb2=true;
}
if(mres20==2)
{
mb2=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"turret "+x+" "+y+" "+minhp+" "+card+" "+damage+" "+firetime+" "+launchtime+" "+speedtime+" "+lv+" "+xn+" "+tutype+" "+tutype2+" "+tutype3+" "+fb+" "+mb+" "+mb2);
mapper.close();
spawn_turret(x, y, minhp, minhp, card, damage, firetime, launchtime, speedtime, lv, xn, tutype, tutype2, tutype3, fb, mb, mb2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="vh")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this vehicle.");
string my=virtual_input_box("","Enter the y of this vehicle.");
string hp=virtual_input_box("","Enter the health of this vehicle.");
string dm=virtual_input_box("","Enter the maximum damage of this vehicle.");
if(x=="" and y=="" and minhp=="" and damage=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
minhp=string_to_number(hp);
damage=string_to_number(dm);
string[] vehicle=find_directories("data/sounds/"+soundpack+"/objects/vehicles/*");
if(vehicle.length()==0)
{
dlg_snd("Error. There are no vehicles available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=vehsmenu();
if(res!="")
{
vehtyp=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres8=m.run("Should the vehicle attack enemies while moving?",true);
if(mres8==0)
{
speak("canceled");
return;
}
if(mres8==1)
{
fb=true;
}
if(mres8==2)
{
fb=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"vehicle "+x+" "+y+" "+minhp+" "+damage+" "+vehtyp+" "+fb);
mapper.close();
spawn_vehicle(x, y, minhp, minhp, damage, vehtyp, fb);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="vp")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this vanishing platform.");
string mx2=virtual_input_box("","Enter the maximum x of this vanishing platform.");
string my=virtual_input_box("","Enter the y of this vanishing platform.");
if(x=="" and paxx=="" and y=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
string[] platform=find_directories("data/sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
string[] vplatform=find_directories("data/sounds/"+soundpack+"/objects/vanishing platforms/*");
if(vplatform.length()==0)
{
dlg_snd("Error. There are no vanishing platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=vplatsmenu();
if(res!="")
{
vplattyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres2= s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres2==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume2=s.get_item_value(0);
pitch2=s.get_item_value(1);
//input.set_only_allowed_chars("1234567890-");
string sp=virtual_input_box("","Enter the speed of this vanishing platform.");
if(speedtime=="")
return;
speedtime=string_to_number(sp);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"vanishing_platform "+x+" "+paxx+" "+y+" "+tiletype+" "+volume+" "+pitch+" "+vplattyp+" "+volume2+" "+pitch2+" "+speedtime);
mapper.close();
spawn_vanishing_platform(x, paxx, y, y, tiletype, volume, pitch, vplattyp, volume2, pitch2, speedtime);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="wl")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this wall.");
string mx2=virtual_input_box("","Enter the maximum x of this wall.");
string my=virtual_input_box("","Enter the minimum y of this wall.");
string my2=virtual_input_box("","Enter the maximum y of this wall.");
string hp=virtual_input_box("","Enter the health of this wall.");
if(x=="" and paxx=="" and y=="" and paxy=="" and minhp=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
minhp=string_to_number(hp);
string[] border=find_directories("data/sounds/"+soundpack+"/objects/walls/*");
if(border.length()==0)
{
dlg_snd("Error. There are no walls available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=wallsmenu();
if(res!="")
{
walltype=res;
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this wall to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"wall "+x+" "+paxx+" "+y+" "+paxy+" "+minhp+" "+walltype+" "+volume+" "+pitch+" "+dmd);
mapper.close();
spawn_wall(x, paxx, y, paxy, minhp, minhp, walltype, volume, pitch, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="zb")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the x of this zombie.");
string my=virtual_input_box("","Enter the y of this zombie.");
string rng=virtual_input_box("","Enter the horizontal attack range of this zombie.");
string rng2=virtual_input_box("","Enter the vertical attack range of this zombie.");
string rng3=virtual_input_box("","Enter the horizontal seeing range of this zombie.");
string rng4=virtual_input_box("","Enter the vertical seeing range of this zombie.");
string hp=virtual_input_box("","Enter the health of this zombie.");
string hc=virtual_input_box("","Enter the maximum lives of this zombie.");
string dm=virtual_input_box("","Enter the maximum damage of this zombie.");
string ft=virtual_input_box("","Enter the fire time of this zombie.");
string sp=virtual_input_box("","Enter the speed of this zombie.");
string lev=virtual_input_box("","Enter the level of this zombie.");
string exper=virtual_input_box("","Enter the xp of this zombie.");
if(x=="" and y=="" and zombrange=="" and zombrange2=="" and zombrange3=="" and zombrange4=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
zombrange=string_to_number(rng);
zombrange2=string_to_number(rng2);
zombrange3=string_to_number(rng3);
zombrange4=string_to_number(rng4);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] zombie=find_directories("data/sounds/"+soundpack+"/npc/normal/zombies/*");
if(zombie.length()==0)
{
dlg_snd("Error. There are no zombies available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=zombiesmenu();
if(res!="")
{
zotype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the zombie attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the zombie move?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the zombie folow you up on other platforms?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres5=m.run("Should the zombie drop an item after killing it?",true);
if(mres5==0)
{
speak("canceled");
return;
}
if(mres5==1)
{
itms=true;
}
if(mres5==2)
{
itms=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"zombie "+x+" "+y+" "+zombrange+" "+zombrange2+" "+zombrange3+" "+zombrange4+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+zotype+" "+fb+" "+mb+" "+mb2+" "+itms);
mapper.close();
spawn_zombie(x, y, zombrange, zombrange2, zombrange3, zombrange4, minhp, minhp, card, damage, firetime, speedtime, lv, xn, zotype, fb, mb, mb2, itms);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="zz")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this zombie zone.");
string mx2=virtual_input_box("","Enter the maximum x of this zombie zone.");
string my=virtual_input_box("","Enter the y of this zombie zone.");
string sp=virtual_input_box("","Enter the spawn time of this zombie zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] zombie=find_directories("data/sounds/"+soundpack+"/npc/normal/zombies/*");
if(zombie.length()==0)
{
dlg_snd("Error. There are no zombies available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=zombiesmenu(true);
if(res!="")
{
zotype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"zombie_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+zotype);
mapper.close();
spawn_zombiezone(x, paxx, y, speedtime, zotype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="zn")
{
//input.set_only_allowed_chars("1234567890-");
string mx=virtual_input_box("","Enter the minimum x of this zone.");
string mx2=virtual_input_box("","Enter the maximum x of this zone.");
string my=virtual_input_box("","Enter the minimum y of this zone.");
string my2=virtual_input_box("","Enter the maximum y of this zone.");
//input.set_only_allowed_chars("none");
string text=virtual_input_box("","Enter the text of this zone.");
if(x=="" and paxx=="" and y=="" and paxy=="" and txt=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
txt=text;
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"zone "+x+" "+paxx+" "+y+" "+paxy+" "+txt);
mapper.close();
spawn_zone(x, paxx, y, paxy, txt);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="addline")
{
mapper.open("data/maps/"+mapname+".map", "ab");
mapdata=mapper.read();
//input.set_only_allowed_chars("none");
string newline=virtual_input_box("","Enter the line you'd like to add.");
resume_pools();
mapper.write("\r\n"+newline);
mapper.close();
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="remline")
{
mapper.open("data/maps/"+mapname+".map", "rb");
mapdata=mapper.read();
string[] lines=string_split(mapdata, "\r\n", true);
string[] filtered_lines;
uint[] original_lines;
filter_empty_lines(lines, filtered_lines, original_lines);
setupmenu();
for (uint i=0; i<filtered_lines.length(); i++)
{
m.add_item_tts(filtered_lines[i],filtered_lines[i], "", true);
}
int mres=m.run("Select a line to remove", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres>3 and mres<=filtered_lines.length())
{
uint original_index=original_lines[mres-1];
lines.remove_at(original_index);
string final;
for (uint i=0; i<lines.length(); i++)
{
if(i>0) final+="\r\n";
final+=lines[i];
}
resume_pools();
mapper.open("data/maps/"+mapname+".map", "wb");
mapdata=mapper.read();
mapper.write(final);
mapper.close();
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
}
if(buildem=="editline")
{
mapper.open("data/maps/" + mapname + ".map", "rb");
mapdata=mapper.read();
mapper.close();
string[] lines=string_split(mapdata, "\r\n", true);
string[] filtered_lines;
uint[] original_lines;
filter_empty_lines(lines, filtered_lines, original_lines);
setupmenu();
for (uint i=0; i<filtered_lines.length(); i++)
{
m.add_item_tts(filtered_lines[i],filtered_lines[i], "", true);
}
int mres=m.run("Select a line to edit", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres>0 and mres<=filtered_lines.length())
{
uint original_index=original_lines[mres-1];
//input.set_only_allowed_chars("none");
string final=virtual_input_box("","line editor", lines[original_index]);
lines[original_index]=final; 
string mapline;
for (uint i=0; i<lines.length(); i++)
{
if(i>0) mapline+="\r\n";
mapline += lines[i];
}
resume_pools();
mapper.open("data/maps/" + mapname + ".map", "wb");
mapper.write(mapline);
mapper.close();
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
}
if(buildem=="dcm")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to delete the current map? This action can't be undone.",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
if(file_exists("data/maps/"+mapname+".map")) file_delete("data/maps/"+mapname+".map");
if(fademode==0) fade_multi_pool(0);
if(fademode==1) fade_multi_pool(1);
speak("map deleted");
dlgplay("mapdelete.ogg",false);
me.x=0;
me.y=0;
clearmap();
destroymap();
mapmenu();
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
if(buildem=="clboard")
{
resume_pools();
mapper.open("data/maps/" + mapname + ".map", "rb");
mapdata=mapper.read();
clipboard_copy_text(mapdata);
speak("The data of "+mapname+" has been copied to your clipboard");
mapper.close();
}
if(buildem=="clboard2")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to overwrite all existing map data with what's on your clipboard?",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
resume_pools();
mapper.open("data/maps/" + mapname + ".map", "wb");
mapdata=mapper.read();
mapdata=clipboard_read_text();
if(mapdata=="") dlg_snd("Error. The map data you've pasted is invalid.");
else
{
resume_pools();
mapper.write(mapdata);
mapper.close();
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
if(buildem=="rcm")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to reload the current map?",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
resume_pools();
load_map(mapname);
speak("map reloaded");
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
}
void pointsmenu()
{
setupmenu();
m.add_item_tts("You're currently on level"+level+"with"+xp+"experience. Your next level requires"+(xprequiered-xp)+"experience.");
m.add_item_tts("You have"+points+"points available to spend.");
m.add_item_tts("upgrade maximum attack,"+"currently set to;"+attack, "umat");
m.add_item_tts("upgrade maximum defence,"+"currently set to;"+defence, "umd");
if(melee==false) m.add_item_tts("upgrade maximum ammo,"+"currently set to;"+maxammo, "uma");
m.add_item_tts("upgrade maximum health,"+"currently set to;"+maxhealth, "umh");
m.add_item_tts("upgrade maximum lives,"+"currently set to;"+lifecard, "umlf");
m.add_item_tts("upgrade maximum shield strength,"+"currently set to;"+maxshieldstrength, "umst");
m.add_item_tts("upgrade maximum shield defence,"+"currently set to;"+shielddefence, "umsd");
m.add_item_tts("upgrade maximum horizontal weapon range,"+"currently set to;"+weprange, "umra1");
m.add_item_tts("upgrade maximum vertical weapon range,"+"currently set to;"+weprange2, "umra2");
m.add_item_tts("back", "back");
int mres=m.run("Points menu. ",true);
string ptmem=m.get_item_name(mres);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(ptmem=="umat")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string att=input.input("How much attack would you like to buy?");
if(attack=="")
return;
int tempstat=string_to_number(att);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
attack+=tempstat;
points-=tempstat;
update_char_attack("data/layouts/characters/"+chartype+"/"+chartype+".sif", attack);
}
}
if(ptmem=="umd")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string def=input.input("How much defence would you like to buy?");
if(defence=="")
return;
int tempstat=string_to_number(def);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
defence+=tempstat;
points-=tempstat;
update_char_defence("data/layouts/characters/"+chartype+"/"+chartype+".sif", defence);
}
}
if(ptmem=="uma")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string amm=input.input("How much ammo would you like to buy?");
if(ammo=="")
return;
int tempstat=string_to_number(amm);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
ammo+=tempstat;
points-=tempstat;
update_wep_ammo(weapontype, weapontype2, ammo);
}
}
if(ptmem=="umh")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string hp=input.input("How much health would you like to buy?");
if(health=="")
return;
int tempstat=string_to_number(hp);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
maxhealth+=tempstat;
points-=tempstat;
update_char_maxhealth("data/layouts/characters/"+chartype+"/"+chartype+".sif", maxhealth);
}
}
if(ptmem=="umlf")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string lc=input.input("How many lives would you like to buy?");
if(lifecard=="")
return;
int tempstat=string_to_number(lc);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
lifecard+=tempstat;
points-=tempstat;
update_char_lives("data/layouts/characters/"+chartype+"/"+chartype+".sif", lifecard);
}
}
if(ptmem=="umst")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string sg=input.input("How much shield strength would you like to buy?");
if(maxshieldstrength=="")
return;
int tempstat=string_to_number(sg);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
maxshieldstrength+=tempstat;
points-=tempstat;
update_shield_max_strength("data/layouts/equipments/shields/"+shieldtype+"/"+shieldtype+".sif", maxshieldstrength);
}
}
if(ptmem=="umsd")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string sd=input.input("How much shield defence would you like to buy?");
if(shielddefence=="")
return;
int tempstat=string_to_number(sd);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
shielddefence+=tempstat;
points-=tempstat;
update_shield_defence("data/layouts/equipments/shields/"+shieldtype+"/"+shieldtype+".sif", shielddefence);
}
}
if(ptmem=="umra1")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string rg1=input.input("How much horizontal weapon range would you like to buy?");
if(weprange=="")
return;
int tempstat=string_to_number(rg1);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
weprange+=tempstat;
points-=tempstat;
update_wep_hl_range(weapontype, weapontype2, weprange);
}
}
if(ptmem=="umra2")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=2)
{
input.set_only_allowed_chars("1234567890-");
string rg2=input.input("How much vertical weapon range would you like to buy?");
if(weprange2=="")
return;
int tempstat=string_to_number(rg2);
p.play_stationary("buy"+random(2,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
weprange2+=tempstat;
points-=tempstat;
update_wep_vl_range(weapontype, weapontype2, weprange2);
}
}
if(ptmem=="back")
{
resume_pools();
return;
}
}
void itemsmenu()
{
setupmenu();
m.add_item_tts("drinks", "refreshments");
m.add_item_tts("foods", "appatiser");
m.add_item_tts("healers", "medical");
m.add_item_tts("back", "back");
int mres=m.run("Items menu",true);
string itsm=m.get_item_name(mres);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(itsm=="refreshments")
{
string res=drinkmenu();
if(res!="")
{
drinktype=res;
drawable=false;
itemcad=1;
useitems=true;
}
}
if(itsm=="appatiser")
{
string res=foodmenu();
if(res!="")
{
foodtype=res;
drawable=false;
itemcad=2;
useitems=true;
}
}
if(itsm=="medical")
{
string res=healermenu();
if(res!="")
{
healtype=res;
drawable=false;
itemcad=3;
useitems=true;
}
}
if(itsm=="back")
{
resume_pools();
return;
}
}
void weaponsmenu()
{
setupmenu();
m.add_item_tts("archery", "arro");
m.add_item_tts("artillery", "shoot");
m.add_item_tts("explosive", "bomb");
m.add_item_tts("melee", "swing");
m.add_item_tts("back", "back");
int mres=m.run("Weapons menu",true);
string wpsm=m.get_item_name(mres);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(wpsm=="arro")
{
string[] archers=find_directories("data/layouts/equipments/weapons/archery/*");
if(archers.length()==0)
{
dlg_snd("Error. There are no archery weapons available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
string[] arclist=find_directories("data/layouts/equipments/weapons/archery/*");
for(uint i=0; i<arclist.length(); i++)
{
arcparse(arclist[i]);
}
string res=archersmenu();
if(res!="")
{
drawable=true;
melee=false;
useitems=false;
weapontype="archery";
weapontype2=res;
}
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
if(wpsm=="shoot")
{
string[] fighters=find_directories("data/layouts/equipments/weapons/artillery/*");
if(fighters.length()==0)
{
dlg_snd("Error. There are no artillery weapons available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
string[] artlist=find_directories("data/layouts/equipments/weapons/artillery/*");
for(uint i=0; i<artlist.length(); i++)
{
artparse(artlist[i]);
}
string res=gunsmenu();
if(res!="")
{
drawable=true;
melee=false;
useitems=false;
weapontype="artillery";
weapontype2=res;
}
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
if(wpsm=="bomb")
{
string[] killers=find_directories("data/layouts/equipments/weapons/explosive/*");
if(killers.length()==0)
{
dlg_snd("Error. There are no explosive weapons available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
string[] exolist=find_directories("data/layouts/equipments/weapons/explosive/*");
for(uint i=0; i<exolist.length(); i++)
{
exoparse(exolist[i]);
}
string res=explosesmenu();
if(res!="")
{
drawable=true;
melee=false;
useitems=false;
weapontype="explosive";
weapontype2=res;
}
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
if(wpsm=="swing")
{
string[] brawlers=find_directories("data/layouts/equipments/weapons/melee/*");
if(brawlers.length()==0)
{
dlg_snd("Error. There are no melee weapons available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
string[] melelist=find_directories("data/layouts/equipments/weapons/melee/*");
for(uint i=0; i<melelist.length(); i++)
{
meleparse(melelist[i]);
}
string res=meleesmenu();
if(res!="")
{
drawable=true;
melee=true;
useitems=false;
weapontype="melee";
weapontype2=res;
}
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
if(wpsm=="back")
{
resume_pools();
return;
}
}
void objinfo()
{
string[] animaltype=find_directories("data/sounds/"+soundpack+"/npc/normal/animals/*");
string[] enemietype=find_directories("data/sounds/"+soundpack+"/npc/normal/enemies/*");
string[] projtype=find_directories("data/sounds/"+soundpack+"/npc/normal/projectiles/*");
string[] robottype=find_directories("data/sounds/"+soundpack+"/npc/normal/robots/*");
string[] spiketype=find_directories("data/sounds/"+soundpack+"/objects/spikes/*");
string[] turtype=find_directories("data/sounds/"+soundpack+"/npc/normal/turrets/*");
string[] vehtype=find_directories("data/sounds/"+soundpack+"/objects/vehicles/*");
string[] zombietype=find_directories("data/sounds/"+soundpack+"/npc/normal/zombies/*");
setupmenu();
m.add_item_tts("total objects "+(animals.length()+bullets.length()+doors.length()+psdoors.length()+enemies.length()+projectiles.length()+robots.length()+spikes.length()+turrets.length()+vehicles.length()+walls.length()+zombies.length()));
for(uint i=0; i<animals.length(); i++)
{
m.add_item_tts(animals[i].animaltype+";"+"at;"+animals[i].amx+";"+animals[i].amy+";"+"HP"+round(animals[i].animalhealth/animals[i].animalmaxhealth*100,2)+"percent"+";"+"level"+animals[i].amlevel);
}
for(uint i=0; i<bullets.length(); i++)
{
m.add_item_tts("bullet at;"+bullets[i].bullx+";"+bullets[i].bully);
}
for(uint i=0; i<doors.length(); i++)
{
m.add_item_tts("door at;"+doors[i].startx+";"+doors[i].starty+";"+"HP"+round(doors[i].doorhealth/doors[i].doormaxhealth*100,2)+"percent");
}
for(uint i=0; i<psdoors.length(); i++)
{
m.add_item_tts("locked door at;"+psdoors[i].startx+";"+psdoors[i].starty+";"+"HP"+round(psdoors[i].psdoorhealth/psdoors[i].psdoormaxhealth*100,2)+"percent");
}
for(uint i=0; i<enemies.length(); i++)
{
m.add_item_tts(enemies[i].enemietype+";"+"at;"+enemies[i].emx+";"+enemies[i].emy+";"+"HP"+round(enemies[i].enemiehealth/enemies[i].enemiemaxhealth*100,2)+"percent"+";"+"level"+enemies[i].emlevel);
}
for(uint i=0; i<projectiles.length(); i++)
{
m.add_item_tts(projectiles[i].projtype+";"+"at;"+projectiles[i].prox+";"+projectiles[i].proy+";"+"HP"+round(projectiles[i].projhealth/projectiles[i].projmaxhealth*100,2)+"percent"+";"+"level"+projectiles[i].projlevel);
}
for(uint i=0; i<robots.length(); i++)
{
m.add_item_tts(robots[i].robottype+";"+"at;"+robots[i].robx+";"+robots[i].roby+";"+"HP"+round(robots[i].robothealth/robots[i].robotmaxhealth*100,2)+"percent"+";"+"level"+robots[i].roblevel);
}
for(uint i=0; i<spikes.length(); i++)
{
m.add_item_tts(spikes[i].spiketype+";"+"at;"+spikes[i].minx+";"+spikes[i].miny+";"+"HP"+round(spikes[i].spikehealth/spikes[i].spikemaxhealth*100,2)+"percent");
}
for(uint i=0; i<turrets.length(); i++)
{
m.add_item_tts(turrets[i].turtype+";"+"at;"+turrets[i].turx+";"+turrets[i].tury+";"+"HP"+round(turrets[i].turhealth/turrets[i].turmaxhealth*100,2)+"percent"+";"+"level"+turrets[i].turlevel);
}
for(uint i=0; i<vehicles.length(); i++)
{
m.add_item_tts(vehicles[i].vehtype+";"+"at;"+vehicles[i].vehx+";"+vehicles[i].vehy+";"+"HP"+round(vehicles[i].vehhealth/vehicles[i].vehmaxhealth*100,2)+"percent");
}
for(uint i=0; i<walls.length(); i++)
{
m.add_item_tts(walls[i].wall+";"+"at;"+walls[i].minx+";"+walls[i].miny+";"+"HP"+round(walls[i].wallhealth/walls[i].wallmaxhealth*100,2)+"percent");
}
for(uint i=0; i<zombies.length(); i++)
{
m.add_item_tts(zombies[i].zombietype+";"+"at;"+zombies[i].zombx+";"+zombies[i].zomby+";"+"HP"+round(zombies[i].zombiehealth/zombies[i].zombiemaxhealth*100,2)+"percent"+";"+"level"+zombies[i].zomblevel);
}
int mres=m.run("Object info", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
resume_pools();
}
void pausemenu()
{
p.play_stationary("pause.ogg",false);
if(autosave==1) writedata();
pause_game();
setupmenu();
m.add_item_tts("resume game", "rmg");
m.add_item_tts("view statistics", "vs");
int mres=m.run("Pause menu. ",true);
string psmem=m.get_item_name(mres);
if(mres==0)
{
p.play_stationary("resume.ogg",false);
if(autosave==1) writedata();
resume_game();
return;
}
if(psmem=="rmg")
{
p.play_stationary("resume.ogg",false);
if(autosave==1) writedata();
resume_game();
return;
}
if(psmem=="vs")
{
statsmenu();
}
}
void statsmenu()
{
setupmenu();
if(gamemode==1) m.add_item_tts("there are;"+animals.length()+"animals spawned on the map.");
if(gamemode==2) m.add_item_tts("there are;"+enemies.length()+"enemies spawned on the map.");
if(gamemode==3) m.add_item_tts("there are;"+projectiles.length()+"projectiles spawned on the map.");
if(gamemode==4) m.add_item_tts("there are;"+robots.length()+"robots spawned on the map.");
if(gamemode==5) m.add_item_tts("there are;"+zombies.length()+"zombies spawned on the map.");
if(gamemode==6) m.add_item_tts("there are;"+animals.length()+amtype+";"+"spawned on the map.");
if(gamemode==7) m.add_item_tts("there are;"+enemies.length()+emtype+";"+"spawned on the map.");
if(gamemode==8) m.add_item_tts("there are;"+projectiles.length()+potype+";"+"spawned on the map.");
if(gamemode==9) m.add_item_tts("there are;"+robots.length()+rotype+";"+"spawned on the map.");
if(gamemode==10) m.add_item_tts("there are;"+zombies.length()+zotype+";"+"spawned on the map.");
if(me.y>=1  and gmt(me.x,me.y)=="") m.add_item_tts("current location,"+me.x+",;"+me.y+","+"you're currently in the air,"+"facing;"+facing);
else if(me.y>=0 ) m.add_item_tts("current location,"+me.x+",;"+me.y+","+"you're walking on;"+gmt(me.x,me.y)+","+"facing;"+facing);
if(lifecard>=2) m.add_item_tts("health, "+round(health/maxhealth*100,2)+"percent, "+health+"of "+maxhealth+"hitpoints remaining, with "+lifecard+"lives left.");
else if(lifecard<=1) m.add_item_tts("health, "+round(health/maxhealth*100,2)+"percent, "+health+"of "+maxhealth+"hitpoints remaining, with "+lifecard+"life left.");
if(shieldon==1) m.add_item_tts("shield strength, "+round(shieldstrength/maxshieldstrength*100,2)+"percent, "+shieldstrength+"of "+maxshieldstrength+"hitpoints remaining.");
m.add_item_tts("Your maximum jump height is"+jumpheight+"squares");
m.add_item_tts("Your maximum x position is"+maxx+"tiles");
m.add_item_tts("Your maximum y position is"+maxy+"tiles");
m.add_item_tts("You're currently on level"+level+"with"+xp+"experience. Your next level requires"+(xprequiered-xp)+"experience.");
m.add_item_tts("You have"+points+"points available to spend.");
if(melee==false) m.add_item_tts("you have "+loadedammo+" out of "+maxammo+" ammo loaded, and "+ammo+" ammo in reserve.");
m.add_item_tts("You have killed a total of"+kills+"entidies.");
m.add_item_tts("You've been playing for a total of;"+timeelapsed.m()+"minutes,"+timeelapsed.s()+"seconds");
m.add_item_tts("back","back");
int mres=m.run("Statistics menu. There are "+(m.get_item_count()-1)+" entries available to view. Press enter to continue.",true);
string stmem=m.get_item_name(mres);
if(mres==0)
{
pausemenu();
}
if(stmem=="back")
{
pausemenu();
}
}
