bool atapex, ascending, building, dlt, dmd, dmt, falling, fb, itm, inp, jb, lp, lpg, mb, mb2;
bool bouncing=true, charhit=true, cammable=true, camsz=false, drawable=true, droppable=true, fireable=true, healable=true, hidedocks=false, hidegames=false, hidemaps=false, hidesets=false, jumpable=true, melee=true, mfc=false, moveable=true, quittable=true, scadder=false, spawnable=true, sittable=true, sitting=false, speedable=true, telable=true, turnable=true, useitems=false;
double x, paxx, y, paxy, x2, pax2, y2, paxy2, minhp, direction, direction2, card, damage, height, firetime, launchtime, lv, ln, pitch, pitch2, speedtime, speedtime2, volume, volume2, volset, xn;
double autovolume=0, automaxvolume=120, autopan=0, automaxpan=100, autopitch=100, automaxpitch=200;
double cameravolume=0, cameramaxvolume=120, camerapan=0, cameramaxpan=100, camerapitch=200, cameramaxpitch=200;
double carvolume=0, carmaxvolume=120, carpan=0, carmaxpan=100, carpitch=100, carmaxpitch=200;
double doorvolume=0, doormaxvolume=120, doorpan=0, doormaxpan=100, doorpitch=100, doormaxpitch=200;
double fallvolume=0, fallmaxvolume=120, fallpan=0, fallmaxpan=100, fallpitch=100, fallmaxpitch=200;
double itemvolume=0, itemmaxvolume=120, itempan=0, itemmaxpan=100, itempitch=100, itemmaxpitch=200;
double painvolume=0, painmaxvolume=120, painpan=0, painmaxpan=100, painpitch=100, painmaxpitch=200;
double shieldvolume=0, shieldmaxvolume=120, shieldpan=0, shieldmaxpan=100, shieldpitch=100, shieldmaxpitch=200;
double tilevolume=0, tilemaxvolume=120, tilepan=0, tilemaxpan=100, tilepitch=100, tilemaxpitch=200;
double wallvolume=0, wallmaxvolume=120, wallpan=0, wallmaxpan=100, wallpitch=100, wallmaxpitch=200;
double weaponvolume=0, weaponmaxvolume=120, weaponpan=0, weaponmaxpan=100, weaponpitch=100, weaponmaxpitch=200;
double attack=0, ammo=100, defence=0, health=100, kills=0, points=0, xp=0, xpmod=1, xprequiered=1, level=1, levmod=1, lifecard=1, loadedammo=100, shieldstrength=100, shielddefence=0, shieldlevel, maxammo=100, maxhealth=100, maxshieldstrength=100, maxx=100, maxy=100, weplevel=1;
float revdry, revwet, revsize, revdamp, revwidth;
int autoslot, camslot, fallslot, invslot, itemslot, painslot, prevslot, shieldloop, shieldslot, shieldremoveslot, shieldwearslot, tileslot, wallslot, weaponslot;
int amrange, amrange2, emrange, emrange2, robrange, robrange2, zombrange, zombrange2, charmode, fallcounter, gamemode, jumping, gametime, musmode, movetime, platmode, sorcemode, ty1, ty2;
int chardeathsound=1, charfallsound=1, charfallsound2=1, charhurtsound=1, charhealsound=1, charhealsound2=1, charhealsound3=1, charinvsound=1, charjumpsound=1, charlevsound=1, charlifesound=1, charrocksound=1, charsitsound=1, charstandsound=1, charturnsound=1;
int shieldbreaksound=1, shielddrawsound=1, shieldhitsound=1, shieldloopsound=1, shieldremovesound=1, shieldwearsound=1;
int wepdrawsound=1, wepemptysound=1, wepfiresound=1, wephitsound=1, weploopsound=1, weprecsound=1, wepreloadsound=1, wepshellsound=1;
int firesound=1, jumpsound=1, hitsound=1, rocksound=1, sitsound=1, spydist=101, standsound=1, switchsound=1, togglesound=1, turnsound=1, telsound=1, tilesound=1, wallsound=1;
int spokenswitch=1, spokentoggle=1, spokenturns=0, spokentel=0, spokenvalues=1;
int aninum=1, autojump=1, autosave=0, cameramode=1, eninum=1, jumpheight=5, keyrowhold=1, locspeech=3, modspeed=5, objinf=1, objnum=1, paused=0, pausem=1, projnum=1, robnum=1, wepdamage=1, weprange=1, weprange2=1, wepspeed=50, wepweight=1, zombnum=1, zonestatus=1;
int hprestoration=0, healthspeech=3, sprestoration=0, itemcad=3, item1delay=50, item2delay=100, item3delay=200, itemhold=1, shieldon=0, shieldweight=1, shieldspeech=3, wephold=0;
int fallspeed=120;
int deffallspeed=120;
int airtime=125, apextime=80, amsptime=500, camtime=100, effectstime=100, emsptime=500, falltime=250, hprestoretime=2200, itemtime1=50, itemtime2=100, itemtime3=200, jumptime=120, jumptime2=80, objsptime=500, prosptime=500, robsptime=500, runtime=500, sprestoretime=2200, stuntime=500, usetime=100, walktime=1000, weapontime=100, weapontime2=100, zombsptime=500;
key_hold cleft(KEY_LEFT,200,modspeed);
key_hold cright(KEY_RIGHT,200,modspeed);
key_hold cup(KEY_UP,200,modspeed);
key_hold cdown(KEY_DOWN,200,modspeed);
string amtype;
string belttyp;
string botype;
string checktyp;
string clostyp;
string calandertyp;
string clocktyp;
string desttyp;
string dlgtyp;
string emtype;
string lifttyp;
string looptyp;
string mplattyp;
string movtyp;
string mustyp;
string opentyp;
string potype;
string rotype;
string signtyp;
string sorcetyp;
string tutype;
string tutype2;
string tutype3;
string vplattyp;
string vehtyp;
string zotype;
string hazztype;
string itemtype;
string itemtype2;
string spiktype;
string teltype;
string hidstatus;
string hidstatus2;
string hidstatus3;
string hidstatus4;
string name;
string password;
string drpassword;
string pspassword;
string reverid;
string tiletype;
string txt;
string txt2;
string walltype;
string weapontype="melee";
string weapontype2="fist";
string camdir="left";
string facing="left";
string tilename="*hardland*, *land*.";
string drinktype="boddle of water";
string foodtype="apple";
string healtype="health drug";
string shieldtype="large shield";
timer airtimer, amsptimer, camtimer, effectstimer, emsptimer, falltimer, hprestoretimer, gametimer, itemtimer1, itemtimer2, itemtimer3, jumptimer, movetimer, objsptimer, prosptimer, robsptimer, runtimer, sprestoretimer, stuntimer, usetimer, walktimer, weapontimer, weapontimer2, zombsptimer;
void buildmenu()
{
setupmenu();
m.add_item_tts("animal", "an");
m.add_item_tts("animal zone", "az");
m.add_item_tts("blockage", "bl");
m.add_item_tts("bomb", "bm");
m.add_item_tts("bomb zone", "bz");
m.add_item_tts("calander", "cn");
m.add_item_tts("checkpoint", "cp");
m.add_item_tts("clock", "cl");
m.add_item_tts("conveyor_belt", "cb");
m.add_item_tts("dialog", "dlg");
m.add_item_tts("door", "ds");
m.add_item_tts("enemy", "em");
m.add_item_tts("enemy zone", "ez");
m.add_item_tts("hazard", "hd");
m.add_item_tts("health zone", "hz");
m.add_item_tts("instrument", "inst");
m.add_item_tts("item", "obj");
m.add_item_tts("item zone", "iz");
m.add_item_tts("lift", "lf");
m.add_item_tts("lockable door", "ld");
m.add_item_tts("lockable passage", "lg");
m.add_item_tts("moving hazard", "mhd");
m.add_item_tts("moving platform", "mpl");
m.add_item_tts("music ambience", "musamb");
m.add_item_tts("music source", "mus");
m.add_item_tts("passage", "psg");
m.add_item_tts("platform", "pf");
m.add_item_tts("projectile", "pj");
m.add_item_tts("projectile zone", "pz");
m.add_item_tts("reverb", "rev");
m.add_item_tts("robot", "rt");
m.add_item_tts("robot zone", "rz");
m.add_item_tts("sign", "sn");
m.add_item_tts("sound ambience", "srcamb");
m.add_item_tts("sound source", "src");
m.add_item_tts("spike", "sp");
m.add_item_tts("spawnpoint", "st");
m.add_item_tts("staircase", "sf");
m.add_item_tts("teleporter", "tp");
m.add_item_tts("text square", "txt");
m.add_item_tts("timed music", "tmc");
m.add_item_tts("timed source", "trc");
m.add_item_tts("timed text", "tmt");
m.add_item_tts("travelpoint", "trp");
m.add_item_tts("turret", "tt");
m.add_item_tts("vanishing platform", "vp");
m.add_item_tts("vehicle", "vh");
m.add_item_tts("wall", "wl");
m.add_item_tts("zombie", "zb");
m.add_item_tts("zombie zone", "zz");
m.add_item_tts("zone", "zn");
m.add_item_tts("add a line", "addline");
m.add_item_tts("edit a line", "editline");
m.add_item_tts("remove a line", "remline");
m.add_item_tts("copy raw map data to clipboard", "clboard");
m.add_item_tts("paste raw map data from clipboard", "clboard2");
m.add_item_tts("delete map", "dcm");
m.add_item_tts("reload map", "rcm");
int mres=m.run("Builder menu",true);
string buildem=m.get_item_name(mres);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(buildem=="srcamb")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this sound ambience.");
string mx2=input.input("Enter the maximum x of this sound ambience.");
string my=input.input("Enter the minimum y of this sound ambience.");
string my2=input.input("Enter the maximum y of this sound ambience.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] soundamb=find_directories("sounds/"+soundpack+"/objects/sources/*");
if(soundamb.length()==0)
{
dlg("Error. There are no sound ambiences available to view.");
resume_pools();
return;
}
else
{
string res=sorcesmenu();
if(res!="")
{
sorcetyp=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol=input.input("Enter the sound volume of this ambience. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone=input.input("Enter the pitch of this sound ambience. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
if(volume=="" and pitch=="")
return;
volume=string_to_number(vol);
pitch=string_to_number(semitone);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"sound_ambience "+x+" "+paxx+" "+y+" "+paxy+" "+sorcetyp+" "+volume+" "+pitch);
mapper.close();
spawn_ambsource(x, paxx, y, paxy, sorcetyp, volume, pitch);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="musamb")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this music ambience.");
string mx2=input.input("Enter the maximum x of this music ambience.");
string my=input.input("Enter the minimum y of this music ambience.");
string my2=input.input("Enter the maximum y of this music ambience.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] musicamb=find_directories("sounds/"+soundpack+"/objects/musics/*");
if(musicamb.length()==0)
{
dlg("Error. There are no music ambiences available to view.");
resume_pools();
return;
}
else
{
string res=musicsmenu();
if(res!="")
{
mustyp=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol=input.input("Enter the volume of this music ambience. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone=input.input("Enter the pitch of this music ambience. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
if(volume=="" and pitch=="")
return;
volume=string_to_number(vol);
pitch=string_to_number(semitone);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"music_ambience "+x+" "+paxx+" "+y+" "+paxy+" "+mustyp+" "+volume+" "+pitch);
mapper.close();
spawn_musicamb(x, paxx, y, paxy, mustyp, volume, pitch);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="an")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this animal.");
string my=input.input("Enter the y of this animal.");
string rng=input.input("Enter the horizontal range of this animal.");
string rng2=input.input("Enter the vertical range of this animal.");
string hp=input.input("Enter the health of this animal.");
string hc=input.input("Enter the maximum lives of this animal.");
string dm=input.input("Enter the maximum damage of this animal.");
string ft=input.input("Enter the fire time of this animal.");
string sp=input.input("Enter the speed of this animal.");
string lev=input.input("Enter the level of this animal.");
string exper=input.input("Enter the xp of this animal.");
if(x=="" and y=="" and amrange=="" and amrange2=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
amrange=string_to_number(rng);
amrange2=string_to_number(rng2);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] animal=find_directories("sounds/"+soundpack+"/npc/animals/*");
if(animal.length()==0)
{
dlg("Error. There are no animals available to view.");
resume_pools();
return;
}
else
{
string res=animalsmenu();
if(res!="")
{
amtype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the animal attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the animal move?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the animal folow you up on other platforms?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"animal "+x+" "+y+" "+amrange+" "+amrange2+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+amtype+" "+fb+" "+mb+" "+mb2);
mapper.close();
spawn_animal(x, y, amrange, amrange2, minhp, minhp, card, damage, firetime, speedtime, lv, xn, amtype, fb, mb, mb2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="az")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this animal zone.");
string mx2=input.input("Enter the maximum x of this animal zone.");
string my=input.input("Enter the y of this animal zone.");
string sp=input.input("Enter the spawn time of this animal zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] animal=find_directories("sounds/"+soundpack+"/npc/animals/*");
if(animal.length()==0)
{
dlg("Error. There are no animals available to view.");
resume_pools();
return;
}
else
{
string res=animalsmenu(true);
if(res!="")
{
amtype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"animal_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+amtype);
mapper.close();
spawn_animalzone(x, paxx, y, speedtime, amtype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="bl")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this blockage.");
string mx2=input.input("Enter the maximum x of this blockage.");
string my=input.input("Enter the minimum y of this blockage.");
string my2=input.input("Enter the maximum y of this blockage.");
input.set_only_allowed_chars("none");
string text=input.input("Enter the text of this blockage.");
if(x=="" and paxx=="" and y=="" and paxy=="" and txt=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
txt=text;
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"blockage "+x+" "+paxx+" "+y+" "+paxy+" "+txt);
mapper.close();
spawn_blockage(x, paxx, y, paxy, txt);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="bm")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this bomb.");
string my=input.input("Enter the y of this bomb.");
string dm=input.input("Enter the maximum damage of this bomb.");
string sp=input.input("Enter the speed of this bomb.");
if(x=="" and y=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
string[] bomb=find_directories("sounds/"+soundpack+"/objects/bombs/*");
if(bomb.length()==0)
{
dlg("Error. There are no bombs available to view.");
resume_pools();
return;
}
else
{
string res=bombsmenu();
if(res!="")
{
botype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"bomb "+x+" "+y+" "+damage+" "+speedtime+" "+botype);
mapper.close();
spawn_bomb(x, y, damage, speedtime, botype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="bz")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this bomb zone.");
string mx2=input.input("Enter the maximum x of this bomb zone.");
string my=input.input("Enter the y of this bomb zone.");
string sp=input.input("Enter the spawn time of this bomb zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] bomb=find_directories("sounds/"+soundpack+"/objects/bombs/*");
if(bomb.length()==0)
{
dlg("Error. There are no bombs available to view.");
resume_pools();
return;
}
else
{
string res=bombsmenu();
if(res!="")
{
botype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"bomb_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+botype);
mapper.close();
spawn_bombzone(x, paxx, y, speedtime, botype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="cn")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this calander.");
string my=input.input("Enter the y of this calander.");
input.set_only_allowed_chars("none");
string text=input.input("Enter the text of this calander.");
if(x=="" and y=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
txt=text;
string[] calander=find_directories("sounds/"+soundpack+"/objects/calanders/*");
if(calander.length()==0)
{
dlg("Error. There are no calanders available to view.");
resume_pools();
return;
}
else
{
string res=calandersmenu();
if(res!="")
{
calandertyp=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this calendar to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"calander "+x+" "+y+" "+txt+" "+calandertyp+" "+dmd);
mapper.close();
spawn_calander(x, y, txt, calandertyp, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="cl")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this clock.");
string my=input.input("Enter the y of this clock.");
input.set_only_allowed_chars("none");
string text=input.input("Enter the text of this clock.");
if(x=="" and y=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
txt=text;
string[] clock=find_directories("sounds/"+soundpack+"/objects/clocks/*");
if(clock.length()==0)
{
dlg("Error. There are no clocks available to view.");
resume_pools();
return;
}
else
{
string res=clocksmenu();
if(res!="")
{
clocktyp=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this clock to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"clock "+x+" "+y+" "+txt+" "+clocktyp+" "+dmd);
mapper.close();
spawn_clock(x, y, txt, clocktyp, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="cb")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this conveyor belt.");
string mx2=input.input("Enter the maximum x of this conveyor belt.");
string my=input.input("Enter the minimum y of this conveyor belt.");
string my2=input.input("Enter the maximum y of this conveyor belt.");
string dr=input.input("Enter the direction of this conveyor belt. 1 for left, 2 for right, 3 for down, and 4 for up.");
string sp=input.input("Enter the speed of this conveyor belt.");
if(x=="" and paxx=="" and y=="" and paxy=="" and direction=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
direction=string_to_number(dr);
speedtime=string_to_number(sp);
string[] platform=find_directories("sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg("Error. There are no platforms available to view.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
string[] belt=find_directories("sounds/"+soundpack+"/objects/belts/*");
if(belt.length()==0)
{
dlg("Error. There are no belts available to view.");
resume_pools();
return;
}
else
{
string res=beltsmenu();
if(res!="")
{
belttyp=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"belt "+x+" "+paxx+" "+y+" "+paxy+" "+direction+" "+speedtime+" "+tiletype+" "+belttyp);
mapper.close();
spawn_belt(x, paxx, y, paxy, direction, speedtime, tiletype, belttyp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="dlg")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this dialog.");
string mx2=input.input("Enter the maximum x of this dialog.");
string my=input.input("Enter the minimum y of this dialog.");
string my2=input.input("Enter the maximum y of this dialog.");
input.set_only_allowed_chars("none");
string text=input.input("Enter the text of this dialog.");
if(x=="" and paxx=="" and y=="" and paxy=="" and txt=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
txt=text;
string[] dialog=find_directories("sounds/"+soundpack+"/objects/dialogs/*");
if(dialog.length()==0)
{
dlg("Error. There are no dialogs available to view.");
resume_pools();
return;
}
else
{
string res=dlgsmenu();
if(res!="")
{
dlgtyp=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres25=m.run("Do you want this dialog to auto activate when stepped on?",true);
if(mres25==0)
{
speak("canceled");
return;
}
if(mres25==1)
{
dlt=true;
}
if(mres25==2)
{
dlt=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"dialog "+x+" "+paxx+" "+y+" "+paxy+" "+txt+" "+dlgtyp+" "+dlt);
mapper.close();
spawn_dialog(x, paxx, y, paxy, txt, dlgtyp, dlt);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="ds")
{
input.set_only_allowed_chars("1234567890-");
string sx=input.input("Enter the starting x of this door.");
string sy=input.input("Enter the starting y of this door.");
string nx=input.input("Enter the finishing x of this door.");
string ny=input.input("Enter the finishing y of this door.");
string hp=input.input("Enter the health of this door.");
string sp=input.input("Enter the speed of this door.");
if(x=="" and y=="" and x2=="" and y2=="" and minhp=="" and speedtime=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
x2=string_to_number(nx);
y2=string_to_number(ny);
minhp=string_to_number(hp);
speedtime=string_to_number(sp);
string[] dloop=find_directories("sounds/"+soundpack+"/objects/doors/loop/*");
if(dloop.length()==0)
{
dlg("Error. There are no door loops available to view.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
looptyp=res;
}
}
string[] dmove=find_directories("sounds/"+soundpack+"/objects/doors/move/*");
if(dmove.length()==0)
{
dlg("Error. There are no door moves available to view.");
resume_pools();
return;
}
else
{
string res2=dmovesmenu();
if(res2!="")
{
movtyp=res2;
}
}
string[] dopen=find_directories("sounds/"+soundpack+"/objects/doors/open/*");
if(dopen.length()==0)
{
dlg("Error. There are no door opens available to view.");
resume_pools();
return;
}
else
{
string res3=dopensmenu();
if(res3!="")
{
opentyp=res3;
}
}
string[] dclose=find_directories("sounds/"+soundpack+"/objects/doors/close/*");
if(dclose.length()==0)
{
dlg("Error. There are no door closes available to view.");
resume_pools();
return;
}
else
{
string res4=dclosesmenu();
if(res4!="")
{
clostyp=res4;
}
}
string[] desttype=find_directories("sounds/"+soundpack+"/objects/doors/dest/*");
if(desttype.length()==0)
{
dlg("Error. There are no door destructions available to view.");
resume_pools();
return;
}
else
{
string res5=destsmenu();
if(res5!="")
{
desttyp=res5;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres27=m.run("Do you want this door to autoactivate when stepped on?",true);
if(mres27==0)
{
speak("canceled");
return;
}
if(mres27==1)
{
dmt=true;
}
if(mres27==2)
{
dmt=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres28=m.run("Do you want this door to be destroyable?",true);
if(mres28==0)
{
speak("canceled");
return;
}
if(mres28==1)
{
dmd=true;
}
if(mres28==2)
{
dmd=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres23=m.run("Would you like to automatically build the opposite side of this door?",true);
if(mres23==0)
{
speak("canceled");
return;
}
if(mres23==1)
{
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"door "+x2+" "+y2+" "+x+" "+y+" "+minhp+" "+speedtime+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_door(x2, y2, x, y, minhp, minhp, speedtime, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(mres23==2)
{
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"door "+x+" "+y+" "+x2+" "+y2+" "+minhp+" "+speedtime+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_door(x, y, x2, y2, minhp, minhp, speedtime, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="ld")
{
input.set_only_allowed_chars("1234567890-");
string sx=input.input("Enter the starting x of this lockable door.");
string sy=input.input("Enter the starting y of this lockable door.");
string nx=input.input("Enter the finishing x of this lockable door.");
string ny=input.input("Enter the finishing y of this lockable door.");
string hp=input.input("Enter the health of this lockable door.");
string sp=input.input("Enter the speed of this lockable door.");
input.set_only_allowed_chars("none");
string ps=input.input("Enter the password of this lockable door.");
if(x=="" and y=="" and x2=="" and y2=="" and minhp=="" and speedtime=="" and drpassword=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
x2=string_to_number(nx);
y2=string_to_number(ny);
minhp=string_to_number(hp);
speedtime=string_to_number(sp);
drpassword=ps;
string[] dloop=find_directories("sounds/"+soundpack+"/objects/doors/loop/*");
if(dloop.length()==0)
{
dlg("Error. There are no door loops available to view.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
looptyp=res;
}
}
string[] dmove=find_directories("sounds/"+soundpack+"/objects/doors/move/*");
if(dmove.length()==0)
{
dlg("Error. There are no door moves available to view.");
resume_pools();
return;
}
else
{
string res2=dmovesmenu();
if(res2!="")
{
movtyp=res2;
}
}
string[] dopen=find_directories("sounds/"+soundpack+"/objects/doors/open/*");
if(dopen.length()==0)
{
dlg("Error. There are no door opens available to view.");
resume_pools();
return;
}
else
{
string res3=dopensmenu();
if(res3!="")
{
opentyp=res3;
}
}
string[] dclose=find_directories("sounds/"+soundpack+"/objects/doors/close/*");
if(dclose.length()==0)
{
dlg("Error. There are no door closes available to view.");
resume_pools();
return;
}
else
{
string res4=dclosesmenu();
if(res4!="")
{
clostyp=res4;
}
}
string[] desttype=find_directories("sounds/"+soundpack+"/objects/doors/dest/*");
if(desttype.length()==0)
{
dlg("Error. There are no door destructions available to view.");
resume_pools();
return;
}
else
{
string res5=destsmenu();
if(res5!="")
{
desttyp=res5;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres27=m.run("Do you want this lockable door to autoactivate when stepped on?",true);
if(mres27==0)
{
speak("canceled");
return;
}
if(mres27==1)
{
dmt=true;
}
if(mres27==2)
{
dmt=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres28=m.run("Do you want this lockable door to be destroyable?",true);
if(mres28==0)
{
speak("canceled");
return;
}
if(mres28==1)
{
dmd=true;
}
if(mres28==2)
{
dmd=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres23=m.run("Would you like to automatically build the opposite side of this lockable door?",true);
if(mres23==0)
{
speak("canceled");
return;
}
if(mres23==1)
{
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"psdoor "+x2+" "+y2+" "+x+" "+y+" "+minhp+" "+speedtime+" "+drpassword+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_psdoor(x2, y2, x, y, minhp, minhp, speedtime, drpassword, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(mres23==2)
{
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"psdoor "+x+" "+y+" "+x2+" "+y2+" "+minhp+" "+speedtime+" "+drpassword+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_psdoor(x, y, x2, y2, minhp, minhp, speedtime, drpassword, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="psg")
{
input.set_only_allowed_chars("1234567890-");
string sx=input.input("Enter the starting x of this passage.");
string sy=input.input("Enter the starting y of this passage.");
string dr=input.input("Enter the direction of this passage. 1 for left to right, and 2 for botum to top.");
string lk=input.input("Enter the maximum length of this passage.");
string sp=input.input("Enter the opening time of this passage.");
if(x=="" and y=="" and direction=="" and ln=="" and speedtime=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
direction=string_to_number(dr);
ln=string_to_number(lk);
speedtime=string_to_number(sp);
string[] platform=find_directories("sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg("Error. There are no platforms available to view.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
string[] dloop=find_directories("sounds/"+soundpack+"/objects/doors/loop/*");
if(dloop.length()==0)
{
dlg("Error. There are no door loops available to view.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
looptyp=res;
}
}
string[] dopen=find_directories("sounds/"+soundpack+"/objects/doors/open/*");
if(dopen.length()==0)
{
dlg("Error. There are no door opens available to view.");
resume_pools();
return;
}
else
{
string res2=dopensmenu();
if(res2!="")
{
opentyp=res2;
}
}
string[] dclose=find_directories("sounds/"+soundpack+"/objects/doors/close/*");
if(dclose.length()==0)
{
dlg("Error. There are no door closes available to view.");
resume_pools();
return;
}
else
{
string res3=dclosesmenu();
if(res3!="")
{
clostyp=res3;
}
}
string sp2=input.input("Enter the closing time of this passage.");
if(speedtime2=="")
return;
speedtime2=string_to_number(sp);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"passage "+x+" "+y+" "+direction+" "+ln+" "+speedtime+" "+tiletype+" "+looptyp+" "+opentyp+" "+clostyp+" "+speedtime2);
mapper.close();
spawn_passage(x, y, direction, ln, speedtime, tiletype, looptyp, opentyp, clostyp, speedtime2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="lg")
{
input.set_only_allowed_chars("1234567890-");
string sx=input.input("Enter the starting x of this lockable passage.");
string sy=input.input("Enter the starting y of this lockable passage.");
string dr=input.input("Enter the direction of this lockable passage. 1 for left to right, and 2 for botum to top.");
string lk=input.input("Enter the maximum length of this lockable passage.");
string sp=input.input("Enter the opening time of this lockable passage.");
if(x=="" and y=="" and direction=="" and ln=="" and speedtime=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
direction=string_to_number(dr);
ln=string_to_number(lk);
speedtime=string_to_number(sp);
string[] platform=find_directories("sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg("Error. There are no platforms available to view.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
string[] dloop=find_directories("sounds/"+soundpack+"/objects/doors/loop/*");
if(dloop.length()==0)
{
dlg("Error. There are no door loops available to view.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
looptyp=res;
}
}
string[] dopen=find_directories("sounds/"+soundpack+"/objects/doors/open/*");
if(dopen.length()==0)
{
dlg("Error. There are no door opens available to view.");
resume_pools();
return;
}
else
{
string res2=dopensmenu();
if(res2!="")
{
opentyp=res2;
}
}
string[] dclose=find_directories("sounds/"+soundpack+"/objects/doors/close/*");
if(dclose.length()==0)
{
dlg("Error. There are no door closes available to view.");
resume_pools();
return;
}
else
{
string res3=dclosesmenu();
if(res3!="")
{
clostyp=res3;
}
}
input.set_only_allowed_chars("none");
string ps=input.input("Enter the password of this lockable passage.");
string sp2=input.input("Enter the closing time of this lockable passage.");
if(pspassword=="" and speedtime2=="")
return;
pspassword=ps;
speedtime2=string_to_number(sp);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"pspassage "+x+" "+y+" "+direction+" "+ln+" "+speedtime+" "+tiletype+" "+looptyp+" "+opentyp+" "+clostyp+" "+pspassword+" "+speedtime2);
mapper.close();
spawn_pspassage(x, y, direction, ln, speedtime, tiletype, looptyp, opentyp, clostyp, pspassword, speedtime2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="em")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this enemy.");
string my=input.input("Enter the y of this enemy.");
string rng=input.input("Enter the horizontal range of this enemy.");
string rng2=input.input("Enter the vertical range of this enemy.");
string hp=input.input("Enter the health of this enemy.");
string hc=input.input("Enter the maximum lives of this enemy.");
string dm=input.input("Enter the maximum damage of this enemy.");
string ft=input.input("Enter the fire time of this enemy.");
string sp=input.input("Enter the speed of this enemy.");
string lev=input.input("Enter the level of this enemy.");
string exper=input.input("Enter the xp of this enemy.");
if(x=="" and y=="" and emrange=="" and emrange2=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
emrange=string_to_number(rng);
emrange2=string_to_number(rng2);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] enemy=find_directories("sounds/"+soundpack+"/npc/enemies/*");
if(enemy.length()==0)
{
dlg("Error. There are no enemies available to view.");
resume_pools();
return;
}
else
{
string res=enemiesmenu();
if(res!="")
{
emtype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the enemy attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the enemy move?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the enemy folow you up on other platforms?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"enemy "+x+" "+y+" "+emrange+" "+emrange2+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+emtype+" "+fb+" "+mb+" "+mb2);
mapper.close();
spawn_enemy(x, y, emrange, emrange2, minhp, minhp, card, damage, firetime, speedtime, lv, xn, emtype, fb, mb, mb2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="ez")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this enemy zone.");
string mx2=input.input("Enter the maximum x of this enemy zone.");
string my=input.input("Enter the y of this enemy zone.");
string sp=input.input("Enter the spawn time of this enemy zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] enemy=find_directories("sounds/"+soundpack+"/npc/enemies/*");
if(enemy.length()==0)
{
dlg("Error. There are no enemies available to view.");
resume_pools();
return;
}
else
{
string res=enemiesmenu(true);
if(res!="")
{
emtype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"enemy_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+emtype);
mapper.close();
spawn_enemyzone(x, paxx, y, speedtime, emtype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="hd")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this hazard.");
string mx2=input.input("Enter the maximum x of this hazard.");
string my=input.input("Enter the minimum y of this hazard.");
string my2=input.input("Enter the maximum y of this hazard.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] hazardtype=find_directories("sounds/"+soundpack+"/objects/hazards/*");
if(hazardtype.length()==0)
{
dlg("Error. There are no hazards available to view.");
resume_pools();
return;
}
else
{
string res=hazardsmenu();
if(res!="")
{
hazztype=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Would you like to automaticly spawn ledges on both sides of this hazard?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
lp=true;
}
if(mres==2)
{
lp=false;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"hazard "+x+" "+paxx+" "+y+" "+paxy+" "+hazztype+" "+lp);
mapper.close();
spawn_hazard(x, paxx, y, paxy, hazztype, lp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="hz")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this health zone.");
string mx2=input.input("Enter the maximum x of this health zone.");
string my=input.input("Enter the minimum y of this health zone.");
string my2=input.input("Enter the maximum y of this health zone.");
string hp=input.input("Enter the health of this health zone.");
string ht=input.input("Enter the healing time of this health zone.");
if(x=="" and paxx=="" and y=="" and paxy=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
damage=string_to_number(hp);
speedtime=string_to_number(ht);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"health_zone "+x+" "+paxx+" "+y+" "+paxy+" "+damage+" "+speedtime);
mapper.close();
spawn_healthzone(x, paxx, y, paxy, damage, speedtime);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="mhd")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the left x of this moving hazard.");
string mx2=input.input("Enter the right x of this moving hazard.");
string my=input.input("Enter the botum y of this moving hazard.");
string my2=input.input("Enter the top y of this moving hazard.");
string sx=input.input("Enter the maximum x length of this moving hazard.");
string sy=input.input("Enter the maximum y length of this moving hazard.");
string dr=input.input("Enter the direction of this moving hazard. 0 for Right and left, 1 for up and down, 2 for Diagonal up/right and down/left, 3 for diagonal up/left and down/right, 4 for Left and right, 5 for Down and up, 6 for Diagonal down/left and up/right, and 7 for diagonal down/right and up/left.");
string sn=input.input("Enter the snap mode of this moving hazard. 0 for no snapping, 1 for forward to snap, 2 for backward to snap, and 3 for snap at ends.");
string sp=input.input("Enter the sspeed of this moving hazard. 100 is equaled to 1000 milliseconds, 50 is equaled to 500 milliseconds, 10 is equaled to 100 milliseconds, 5 is equaled to 50 milliseconds, and 1 is equaled to 10 milliseconds.");
if(x=="" and paxx=="" and y=="" and paxy=="" and x2=="" and y2=="" and direction=="" and direction2=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
x2=string_to_number(sx);
y2=string_to_number(sy);
direction=string_to_number(dr);
direction2=string_to_number(sn);
speedtime=string_to_number(sp);
string[] hazardtype=find_directories("sounds/"+soundpack+"/objects/hazards/*");
if(hazardtype.length()==0)
{
dlg("Error. There are no hazards available to view.");
resume_pools();
return;
}
else
{
string res=hazardsmenu();
if(res!="")
{
hazztype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"mhazard "+x+" "+paxx+" "+y+" "+paxy+" "+x2+" "+y2+" "+direction+" "+direction2+" "+speedtime+" "+hazztype);
mapper.close();
spawn_moving_hazard(x, paxx, y, paxy, x2, y2, direction, direction2, speedtime, hazztype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="mpl")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the left x of this moving platform.");
string mx2=input.input("Enter the right x of this moving platform.");
string my=input.input("Enter the botum y of this moving platform.");
string my2=input.input("Enter the top y of this moving platform.");
string sx=input.input("Enter the maximum x length of this moving platform.");
string dr=input.input("Enter the direction of this moving platform. 0 for Right and left, 1 for up and down, 2 for Diagonal up/right and down/left, 3 for diagonal up/left and down/right, 4 for Left and right, 5 for Down and up, 6 for Diagonal down/left and up/right, and 7 for diagonal down/right and up/left.");
string sn=input.input("Enter the snap mode of this moving platform. 0 for no snapping, 1 for forward to snap, 2 for backward to snap, and 3 for snap at ends.");
string sp=input.input("Enter the sspeed of this moving platform. 100 is equaled to 1000 milliseconds, 50 is equaled to 500 milliseconds, 10 is equaled to 100 milliseconds, 5 is equaled to 50 milliseconds, and 1 is equaled to 10 milliseconds.");
if(x=="" and paxx=="" and y=="" and paxy=="" and x2=="" and direction=="" and direction2=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
x2=string_to_number(sx);
direction=string_to_number(dr);
direction2=string_to_number(sn);
speedtime=string_to_number(sp);
string[] platform=find_directories("sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg("Error. There are no platforms available to view.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol=input.input("Enter the volume of this platform. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone=input.input("Enter the pitch of this platform. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
if(volume=="" and pitch=="")
return;
volume=string_to_number(vol);
pitch=string_to_number(semitone);
string[] mplatform=find_directories("sounds/"+soundpack+"/objects/moving platforms/*");
if(mplatform.length()==0)
{
dlg("Error. There are no moving platforms available to view.");
resume_pools();
return;
}
else
{
string res=mplatsmenu();
if(res!="")
{
mplattyp=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol2=input.input("Enter the volume of this moving platform. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone2=input.input("Enter the pitch of this moving platform. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
string vof=input.input("Enter the volume offset of this moving platform.");
if(volume2=="" and pitch2=="" and volset=="")
return;
volume2=string_to_number(vol2);
pitch2=string_to_number(semitone2);
volset=string_to_number(vof);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"mplatform "+x+" "+paxx+" "+y+" "+paxy+" "+x2+" "+direction+" "+direction2+" "+speedtime+" "+tiletype+" "+volume+" "+pitch+" "+mplattyp+" "+volume2+" "+pitch2+" "+volset);
mapper.close();
spawn_moving_platform(x, paxx, y, paxy, x2, direction, direction2, speedtime, tiletype, volume, pitch, mplattyp, volume2, pitch2, volset);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="cp")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this checkpoint.");
string my=input.input("Enter the y of this checkpoint.");
string sp=input.input("Enter the speed of this checkpoint. Press enter to use the default speed, or control backspace to clear the input to type your own speed.", "350");
if(x=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] checktype=find_directories("sounds/"+soundpack+"/objects/checkpoints/*");
if(checktype.length()==0)
{
dlg("Error. There are no checkpoints available to view.");
resume_pools();
return;
}
else
{
string res=checksmenu();
if(res!="")
{
checktyp=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"checkpoint "+x+" "+y+" "+speedtime+" "+checktyp);
mapper.close();
spawn_checkpoint(x, y, speedtime, checktyp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="inst")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this instrument.");
string mx2=input.input("Enter the maximum x of this instrument.");
string my=input.input("Enter the minimum y of this instrument.");
string my2=input.input("Enter the maximum y of this instrument.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Would you like spoken instructions upon pressing Enter?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
inp=true;
}
if(mres==2)
{
inp=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"instrument "+x+" "+paxx+" "+y+" "+paxy+" "+inp);
mapper.close();
spawn_instrument(x, paxx, y, paxy, inp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="obj")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this item.");
string my=input.input("Enter the y of this item.");
string sp=input.input("Enter the speed of this item. Press enter to use the default speed, or control backspace to clear the input to type your own speed.", "500");
if(x=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
speedtime=string_to_number(sp);
setupmenu();
m.add_item_tts("health", "hp");
m.add_item_tts("other", "ot");
int mres=m.run("Items menu",true);
string itsm=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
return;
}
if(itsm=="hp")
{
string[] ithealth=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(ithealth.length()==0)
{
dlg("Error. There are no health items available to view.");
resume_pools();
return;
}
else
{
string res=healthsmenu();
if(res!="")
{
itemtype="health";
itemtype2=res;
}
}
}
if(itsm=="ot")
{
string[] itother=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/other/*");
if(itother.length()==0)
{
dlg("Error. There are no other items available to view.");
resume_pools();
return;
}
else
{
string res=othersmenu();
if(res!="")
{
itemtype="other";
itemtype2=res;
}
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres28=m.run("Do you want this item to be autograbbed when stepped on?",true);
if(mres28==0)
{
speak("canceled");
return;
}
if(mres28==1)
{
itm=true;
}
if(mres28==2)
{
itm=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"item "+x+" "+y+" "+speedtime+" "+itemtype+" "+itemtype2+" "+itm);
mapper.close();
spawn_obj(x, y, speedtime, itemtype, itemtype2, itm);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="iz")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this item zone.");
string mx2=input.input("Enter the maximum x of this item zone.");
string my=input.input("Enter the minimum y of this item zone.");
string my2=input.input("Enter the maximum y of this item zone.");
string sp=input.input("Enter the spawn time of this item zone.");
if(x=="" and paxx=="" and y=="" and paxy=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
speedtime=string_to_number(sp);
setupmenu();
m.add_item_tts("health", "hp");
m.add_item_tts("other", "ot");
int mres=m.run("Items menu",true);
string itsm=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
return;
}
if(itsm=="hp")
{
string[] ithealth=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(ithealth.length()==0)
{
dlg("Error. There are no health items available to view.");
resume_pools();
return;
}
else
{
string res=healthsmenu();
if(res!="")
{
itemtype="health";
itemtype2=res;
}
}
}
if(itsm=="ot")
{
string[] itother=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/other/*");
if(itother.length()==0)
{
dlg("Error. There are no other items available to view.");
resume_pools();
return;
}
else
{
string res=othersmenu();
if(res!="")
{
itemtype="other";
itemtype2=res;
}
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"item_zone "+x+" "+paxx+" "+y+" "+paxy+" "+speedtime+" "+itemtype+" "+itemtype2);
mapper.close();
spawn_objzone(x, paxx, y, paxy, speedtime, itemtype, itemtype2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="lf")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this lift.");
string mx2=input.input("Enter the maximum x of this lift.");
string my=input.input("Enter the minimum y of this lift.");
string my2=input.input("Enter the maximum y of this lift.");
string dr=input.input("Enter the direction of this lift. 0 for down and up, and 1 for up and down.");
string sp=input.input("Enter the speed of this lift.");
if(x=="" and paxx=="" and y=="" and paxy=="" and direction=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
direction=string_to_number(dr);
speedtime=string_to_number(sp);
string[] platform=find_directories("sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg("Error. There are no platforms available to view.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol=input.input("Enter the volume of this platform. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone=input.input("Enter the pitch of this platform. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
if(volume=="" and pitch=="")
return;
volume=string_to_number(vol);
pitch=string_to_number(semitone);
string[] liftform=find_directories("sounds/"+soundpack+"/objects/lifts/*");
if(liftform.length()==0)
{
dlg("Error. There are no lifts available to view.");
resume_pools();
return;
}
else
{
string res=liftsmenu();
if(res!="")
{
lifttyp=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol2=input.input("Enter the volume of this lift. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone2=input.input("Enter the pitch of this lift. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
if(volume2=="" and pitch2=="")
return;
volume2=string_to_number(vol2);
pitch2=string_to_number(semitone2);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"lift "+x+" "+paxx+" "+y+" "+paxy+" "+direction+" "+speedtime+" "+tiletype+" "+volume+" "+pitch+" "+lifttyp+" "+volume2+" "+pitch2);
mapper.close();
spawn_lift(x, paxx, y, paxy, direction, speedtime, tiletype, volume, pitch, lifttyp, volume2, pitch2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="mus")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this music source.");
string mx2=input.input("Enter the maximum x of this music source.");
string my=input.input("Enter the minimum y of this music source.");
string my2=input.input("Enter the maximum y of this music source.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] music=find_directories("sounds/"+soundpack+"/objects/musics/*");
if(music.length()==0)
{
dlg("Error. There are no music sources available to view.");
resume_pools();
return;
}
else
{
string res=musicsmenu();
if(res!="")
{
mustyp=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol=input.input("Enter the volume of this music source. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone=input.input("Enter the pitch of this music source. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
if(volume=="" and pitch=="")
return;
volume=string_to_number(vol);
pitch=string_to_number(semitone);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"music_source "+x+" "+paxx+" "+y+" "+paxy+" "+mustyp+" "+volume+" "+pitch);
mapper.close();
spawn_musicsource(x, paxx, y, paxy, mustyp, volume, pitch);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="pf")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this platform.");
string mx2=input.input("Enter the maximum x of this platform.");
string my=input.input("Enter the y of this platform.");
if(x=="" and paxx=="" and y=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
string[] platform=find_directories("sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg("Error. There are no platforms available to view.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol=input.input("Enter the volume of this platform. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone=input.input("Enter the pitch of this platform. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
if(volume=="" and pitch=="")
return;
volume=string_to_number(vol);
pitch=string_to_number(semitone);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"platform "+x+" "+paxx+" "+y+" "+tiletype+" "+volume+" "+pitch);
mapper.close();
spawn_platform(x, paxx, y, y, tiletype, volume, pitch);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="pj")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this projectile.");
string my=input.input("Enter the y of this projectile.");
string dr=input.input("Enter the direction of this projectile. 0 for left, and 1 for right");
string hp=input.input("Enter the health of this projectile.");
string hc=input.input("Enter the maximum lives of this projectile.");
string dm=input.input("Enter the maximum damage of this projectile.");
string sp=input.input("Enter the speed of this projectile.");
string lev=input.input("Enter the level of this projectile.");
string exper=input.input("Enter the xp of this projectile.");
if(x=="" and y=="" and direction=="" and minhp=="" and card=="" and damage=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
direction=string_to_number(dr);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] projectile=find_directories("sounds/"+soundpack+"/npc/projectiles/*");
if(projectile.length()==0)
{
dlg("Error. There are no projectiles available to view.");
resume_pools();
return;
}
else
{
string res=projesmenu();
if(res!="")
{
potype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres8=m.run("Should the projectile attack you?",true);
if(mres8==0)
{
speak("canceled");
return;
}
if(mres8==1)
{
fb=true;
}
if(mres8==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres9=m.run("Should the projectile move?",true);
if(mres9==0)
{
speak("canceled");
return;
}
if(mres9==1)
{
mb=true;
}
if(mres9==2)
{
mb=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"projectile "+x+" "+y+" "+direction+" "+minhp+" "+card+" "+damage+" "+speedtime+" "+lv+" "+xn+" "+potype+" "+fb+" "+mb);
mapper.close();
spawn_projectile(x, y, direction, minhp, minhp, card, damage, speedtime, lv, xn, potype, fb, mb);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="pz")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this projectile zone.");
string mx2=input.input("Enter the maximum x of this projectile zone.");
string my=input.input("Enter the y of this projectile zone.");
string sp=input.input("Enter the spawn time of this projectile zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] projectile=find_directories("sounds/"+soundpack+"/npc/projectiles/*");
if(projectile.length()==0)
{
dlg("Error. There are no projectiles available to view.");
resume_pools();
return;
}
else
{
string res=projesmenu(true);
if(res!="")
{
potype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"projectile_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+potype);
mapper.close();
spawn_projzone(x, paxx, y, speedtime, potype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="rev")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this reverb.");
string mx2=input.input("Enter the maximum x of this reverb.");
string my=input.input("Enter the minimum y of this reverb.");
string my2=input.input("Enter the maximum y of this reverb.");
input.set_only_allowed_chars("none");
string rd=input.input("Enter the id of this reverb. Press enter to use a random reverb id, or control backspace to clear the input to type your own reverb id.", generate_token(random(5,10)));
if(x=="" and paxx=="" and y=="" and paxy=="" and reverid=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
reverid=rd;
reverbmenu();
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"reverb "+x+" "+paxx+" "+y+" "+paxy+" "+reverid+" "+revdry+" "+revwet+" "+revsize+" "+revdamp+" "+revwidth);
mapper.close();
spawn_reverb_effect(x, paxx, y, paxy, reverid, revdry, revwet, revsize, revdamp, revwidth);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="rt")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this robot.");
string my=input.input("Enter the y of this robot.");
string rng=input.input("Enter the horizontal range of this robot.");
string rng2=input.input("Enter the vertical range of this robot.");
string hp=input.input("Enter the health of this robot.");
string hc=input.input("Enter the maximum lives of this robot.");
string dm=input.input("Enter the maximum damage of this robot.");
string ft=input.input("Enter the fire time of this robot.");
string sp=input.input("Enter the speed of this robot.");
string lev=input.input("Enter the level of this robot.");
string exper=input.input("Enter the xp of this robot.");
if(x=="" and y=="" and robrange=="" and robrange2=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
robrange=string_to_number(rng);
robrange2=string_to_number(rng2);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] robot=find_directories("sounds/"+soundpack+"/npc/robots/*");
if(robot.length()==0)
{
dlg("Error. There are no robots available to view.");
resume_pools();
return;
}
else
{
string res=robotsmenu();
if(res!="")
{
rotype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the robot attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the robot move?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the robot folow you up on other platforms?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"robot "+x+" "+y+" "+robrange+" "+robrange2+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+rotype+" "+fb+" "+mb+" "+mb2);
mapper.close();
spawn_robot(x, y, robrange, robrange2, minhp, minhp, card, damage, firetime, speedtime, lv, xn, rotype, fb, mb, mb2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="rz")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this robot zone.");
string mx2=input.input("Enter the maximum x of this robot zone.");
string my=input.input("Enter the y of this robot zone.");
string sp=input.input("Enter the spawn time of this robot zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] robot=find_directories("sounds/"+soundpack+"/npc/robots/*");
if(robot.length()==0)
{
dlg("Error. There are no robots available to view.");
resume_pools();
return;
}
else
{
string res=robotsmenu(true);
if(res!="")
{
rotype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"robot_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+rotype);
mapper.close();
spawn_robotzone(x, paxx, y, speedtime, rotype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="sn")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this sign.");
string my=input.input("Enter the y of this sign.");
input.set_only_allowed_chars("none");
string text=input.input("Enter the text of this sign.");
if(x=="" and y=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
txt=text;
string[] signs=find_directories("sounds/"+soundpack+"/objects/signs/*");
if(signs.length()==0)
{
dlg("Error. There are no signs available to view.");
resume_pools();
return;
}
else
{
string res=signsmenu();
if(res!="")
{
signtyp=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this sign to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Would you like the sign sound to be looped?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
lpg=true;
}
if(mres==2)
{
lpg=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"sign "+x+" "+y+" "+txt+" "+signtyp+" "+dmd+" "+lpg);
mapper.close();
spawn_sign(x, y, txt, signtyp, dmd, lpg);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="src")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this sound source.");
string mx2=input.input("Enter the maximum x of this sound source.");
string my=input.input("Enter the minimum y of this sound source.");
string my2=input.input("Enter the maximum y of this sound source.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] source=find_directories("sounds/"+soundpack+"/objects/sources/*");
if(source.length()==0)
{
dlg("Error. There are no sources available to view.");
resume_pools();
return;
}
else
{
string res=sorcesmenu();
if(res!="")
{
sorcetyp=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol=input.input("Enter the volume of this sound source. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone=input.input("Enter the pitch of this sound source. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
if(volume=="" and pitch=="")
return;
volume=string_to_number(vol);
pitch=string_to_number(semitone);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"sound_source "+x+" "+paxx+" "+y+" "+paxy+" "+sorcetyp+" "+volume+" "+pitch);
mapper.close();
spawn_soundsource(x, paxx, y, paxy, sorcetyp, volume, pitch);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="sp")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this spike.");
string mx2=input.input("Enter the maximum x of this spike.");
string my=input.input("Enter the minimum y of this spike.");
string my2=input.input("Enter the maximum y of this spike.");
string hp=input.input("Enter the health of this spike.");
string dm=input.input("Enter the maximum damage of this spike.");
string sp=input.input("Enter the speed of this spike.");
if(x=="" and paxx=="" and y=="" and paxy=="" and minhp=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
minhp=string_to_number(hp);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
string[] spike=find_directories("sounds/"+soundpack+"/objects/spikes/*");
if(spike.length()==0)
{
dlg("Error. There are no spikes available to view.");
resume_pools();
return;
}
else
{
string res=spikesmenu();
if(res!="")
{
spiktype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this spike to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"spike "+x+" "+paxx+" "+y+" "+paxy+" "+minhp+" "+damage+" "+speedtime+" "+spiktype+" "+dmd);
mapper.close();
spawn_spike(x, paxx, y, paxy, minhp, minhp, damage, speedtime, spiktype, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="st")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this spawnpoint.");
string my=input.input("Enter the y of this spawnpoint.");
if(x=="" and y=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"spawnpoint "+x+" "+y);
mapper.close();
create_spawnpoint(x, y);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="sf")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this staircase.");
string mx2=input.input("Enter the maximum x of this staircase.");
string my=input.input("Enter the minimum y of this staircase.");
string my2=input.input("Enter the maximum y of this staircase.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] platform=find_directories("sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg("Error. There are no platforms available to view.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"staircase "+x+" "+paxx+" "+y+" "+paxy+" "+tiletype);
mapper.close();
spawn_staircase(x, paxx, y, paxy, tiletype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="tp")
{
input.set_only_allowed_chars("1234567890-");
string sx=input.input("Enter the starting x of this teleporter.");
string sy=input.input("Enter the starting y of this teleporter.");
string nx=input.input("Enter the finishing x of this teleporter.");
string ny=input.input("Enter the finishing y of this teleporter.");
string dr=input.input("Enter the direction of this teleporter. 0 for left, and 1 for right.");
string sp=input.input("Enter the speed of this teleporter.");
if(x=="" and y=="" and x2=="" and y2=="" and direction=="" and speedtime=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
x2=string_to_number(nx);
y2=string_to_number(ny);
direction=string_to_number(dr);
speedtime=string_to_number(sp);
string[] teleporter=find_directories("sounds/"+soundpack+"/objects/teleporters/*");
if(teleporter.length()==0)
{
dlg("Error. There are no teleporters available to view.");
resume_pools();
return;
}
else
{
string res=teleportersmenu();
if(res!="")
{
teltype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres16=m.run("Should the teleporter move?",true);
if(mres16==0)
{
speak("canceled");
return;
}
if(mres16==1)
{
mb=true;
}
if(mres16==2)
{
mb=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"teleporter "+x+" "+y+" "+x2+" "+y2+" "+direction+" "+speedtime+" "+teltype+" "+mb);
mapper.close();
spawn_teleporter(x, y, x2, y2, direction, speedtime, teltype, mb);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="txt")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this text square.");
string my=input.input("Enter the y of this text square.");
input.set_only_allowed_chars("none");
string text=input.input("Enter the text of this text square.");
if(x=="" and y=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
txt=text;
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"text_square "+x+" "+y+" "+txt);
mapper.close();
spawn_text_square(x, y, txt);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="trc")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this timed source.");
string mx2=input.input("Enter the maximum x of this timed source.");
string my=input.input("Enter the minimum y of this timed source.");
string my2=input.input("Enter the maximum y of this timed source.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] source=find_directories("sounds/"+soundpack+"/objects/sources/*");
if(source.length()==0)
{
dlg("Error. There are no sources available to view.");
resume_pools();
return;
}
else
{
string res=sorcesmenu();
if(res!="")
{
sorcetyp=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol=input.input("Enter the volume of this timed source. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone=input.input("Enter the pitch of this timed source. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
string sp=input.input("Enter the speed of this timed source.");
if(volume=="" and pitch=="" and speedtime=="")
return;
volume=string_to_number(vol);
pitch=string_to_number(semitone);
speedtime=string_to_number(sp);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"timed_source "+x+" "+paxx+" "+y+" "+paxy+" "+sorcetyp+" "+volume+" "+pitch+" "+speedtime);
mapper.close();
spawn_timedsource(x, paxx, y, paxy, volume, pitch, speedtime, sorcetyp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="tmc")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this timed music.");
string mx2=input.input("Enter the maximum x of this timed music.");
string my=input.input("Enter the minimum y of this timed music.");
string my2=input.input("Enter the maximum y of this timed music.");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] music=find_directories("sounds/"+soundpack+"/objects/musics/*");
if(music.length()==0)
{
dlg("Error. There are no musics available to view.");
resume_pools();
return;
}
else
{
string res=musicsmenu();
if(res!="")
{
mustyp=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol=input.input("Enter the volume of this timed music. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone=input.input("Enter the pitch of this timed music. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
string sp=input.input("Enter the speed of this timed music.");
if(volume=="" and pitch=="" and speedtime=="")
return;
volume=string_to_number(vol);
pitch=string_to_number(semitone);
speedtime=string_to_number(sp);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"timed_music "+x+" "+paxx+" "+y+" "+paxy+" "+mustyp+" "+volume+" "+pitch+" "+speedtime);
mapper.close();
spawn_timedmusic(x, paxx, y, paxy, volume, pitch, speedtime, mustyp);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="tmt")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this timed text.");
string mx2=input.input("Enter the maximum x of this timed text.");
string my=input.input("Enter the minimum y of this timed text.");
string my2=input.input("Enter the maximum y of this timed text.");
string sp=input.input("Enter the speed of this timed text.");
input.set_only_allowed_chars("none");
string text=input.input("Enter the text of this timed text.");
if(x=="" and paxx=="" and y=="" and paxy=="" and speedtime=="" and txt=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
speedtime=string_to_number(sp);
txt=text;
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"timed_text "+x+" "+paxx+" "+y+" "+paxy+" "+speedtime+" "+txt);
mapper.close();
spawn_timedtext(x, paxx, y, paxy, speedtime, txt);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="trp")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this travelpoint.");
string mx2=input.input("Enter the maximum x of this travelpoint.");
string my=input.input("Enter the minimum y of this travelpoint.");
string my2=input.input("Enter the maximum y of this travelpoint.");
input.set_only_allowed_chars("none");
string mtext=input.input("Enter the destenation map of this travelpoint.");
input.set_only_allowed_chars("1234567890-");
string dx=input.input("Enter the destenation x of this travelpoint.");
string dy=input.input("Enter the destenation y of this travelpoint.");
input.set_only_allowed_chars("none");
string dtext=input.input("Enter the destenation text of this travelpoint.");
if(x=="" and paxx=="" and y=="" and paxy=="" and txt=="" and x2=="" and y2=="" and txt2=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
txt=mtext;
x2=string_to_number(dx);
y2=string_to_number(dy);
txt2=dtext;
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Would you like to automatically build the opposite side of this travelpoint?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
string mtext2=input.input("Enter the destenation map of this travelpoint to go back to.");
if(txt=="")
return;
txt=mtext2;
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"travelpoint "+x+" "+paxx+" "+y+" "+paxy+" "+txt+" "+y2+" "+x2+" "+txt2);
mapper.close();
spawn_travelpoint(x, paxx, y, paxy, txt, y2, x2, txt2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(mres==2)
{
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"travelpoint "+x+" "+paxx+" "+y+" "+paxy+" "+txt+" "+x2+" "+y2+" "+txt2);
mapper.close();
spawn_travelpoint(x, paxx, y, paxy, txt, x2, y2, txt2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="tt")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this turret.");
string my=input.input("Enter the y of this turret.");
string hp=input.input("Enter the health of this turret.");
string hc=input.input("Enter the maximum lives of this turret.");
string dm=input.input("Enter the maximum damage of this turret.");
string ft=input.input("Enter the fire time of this turret.");
string lt=input.input("Enter the launch time of this turret.");
string sp=input.input("Enter the speed of this turret.");
string lev=input.input("Enter the level of this turret.");
string exper=input.input("Enter the xp of this turret.");
if(x=="" and y=="" and minhp=="" and card=="" and damage=="" and firetime=="" and launchtime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
launchtime=string_to_number(lt);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] turret=find_directories("sounds/"+soundpack+"/npc/turrets/*");
if(turret.length()==0)
{
dlg("Error. There are no turrets available to view.");
resume_pools();
return;
}
else
{
string res=turretsmenu();
if(res!="")
{
tutype=res;
}
}
setupmenu();
m.add_item_tts("animal","an2");
m.add_item_tts("enemy","em2");
m.add_item_tts("projectile","pj2");
m.add_item_tts("robot","rt2");
m.add_item_tts("zombie","zb2");
int mres=m.run("What would you like this turret to spawn?",true);
string buildem2=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
return;
}
if(buildem2=="an2")
{
string[] animal=find_directories("sounds/"+soundpack+"/npc/animals/*");
if(animal.length()==0)
{
dlg("Error. There are no animals available to view.");
resume_pools();
return;
}
else
{
string res=animalsmenu();
if(res!="")
{
tutype2="animal";
tutype3=res;
}
}
}
if(buildem2=="em2")
{
string[] enemy=find_directories("sounds/"+soundpack+"/npc/enemies/*");
if(enemy.length()==0)
{
dlg("Error. There are no enemies available to view.");
resume_pools();
return;
}
else
{
string res=enemiesmenu();
if(res!="")
{
tutype2="enemy";
tutype3=res;
}
}
}
if(buildem2=="pj2")
{
string[] projectile=find_directories("sounds/"+soundpack+"/npc/projectiles/*");
if(projectile.length()==0)
{
dlg("Error. There are no projectiles available to view.");
resume_pools();
return;
}
else
{
string res=projesmenu();
if(res!="")
{
tutype2="projectile";
tutype3=res;
}
}
}
if(buildem2=="rt2")
{
string[] robot=find_directories("sounds/"+soundpack+"/npc/robots/*");
if(robot.length()==0)
{
dlg("Error. There are no robots available to view.");
resume_pools();
return;
}
else
{
string res=robotsmenu();
if(res!="")
{
tutype2="robot";
tutype3=res;
}
}
}
if(buildem2=="zb2")
{
string[] zombie=find_directories("sounds/"+soundpack+"/npc/zombies/*");
if(zombie.length()==0)
{
dlg("Error. There are no zombies available to view.");
resume_pools();
return;
}
else
{
string res=zombiesmenu();
if(res!="")
{
tutype2="zombie";
tutype3=res;
}
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres18=m.run("Should the turret attack you?",true);
if(mres18==0)
{
speak("canceled");
return;
}
if(mres18==1)
{
fb=true;
}
if(mres18==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres19=m.run("Should the turret move?",true);
if(mres19==0)
{
speak("canceled");
return;
}
if(mres19==1)
{
mb=true;
}
if(mres19==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres20=m.run("Should the turret folow you up on other platforms?",true);
if(mres20==0)
{
speak("canceled");
return;
}
if(mres20==1)
{
mb2=true;
}
if(mres20==2)
{
mb2=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"turret "+x+" "+y+" "+minhp+" "+card+" "+damage+" "+firetime+" "+launchtime+" "+speedtime+" "+lv+" "+xn+" "+tutype+" "+tutype2+" "+tutype3+" "+fb+" "+mb+" "+mb2);
mapper.close();
spawn_turret(x, y, minhp, minhp, card, damage, firetime, launchtime, speedtime, lv, xn, tutype, tutype2, tutype3, fb, mb, mb2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="vh")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this vehicle.");
string my=input.input("Enter the y of this vehicle.");
string hp=input.input("Enter the health of this vehicle.");
string dm=input.input("Enter the maximum damage of this vehicle.");
if(x=="" and y=="" and minhp=="" and damage=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
minhp=string_to_number(hp);
damage=string_to_number(dm);
string[] vehicle=find_directories("sounds/"+soundpack+"/objects/vehicles/*");
if(vehicle.length()==0)
{
dlg("Error. There are no vehicles available to view.");
resume_pools();
return;
}
else
{
string res=vehsmenu();
if(res!="")
{
vehtyp=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres8=m.run("Should the vehicle attack enemies while moving?",true);
if(mres8==0)
{
speak("canceled");
return;
}
if(mres8==1)
{
fb=true;
}
if(mres8==2)
{
fb=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"vehicle "+x+" "+y+" "+minhp+" "+damage+" "+vehtyp+" "+fb);
mapper.close();
spawn_vehicle(x, y, minhp, minhp, damage, vehtyp, fb);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="vp")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this vanishing platform.");
string mx2=input.input("Enter the maximum x of this vanishing platform.");
string my=input.input("Enter the y of this vanishing platform.");
if(x=="" and paxx=="" and y=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
string[] platform=find_directories("sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg("Error. There are no platforms available to view.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol=input.input("Enter the volume of this platform. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone=input.input("Enter the pitch of this platform. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
if(volume=="" and pitch=="")
return;
volume=string_to_number(vol);
pitch=string_to_number(semitone);
string[] vplatform=find_directories("sounds/"+soundpack+"/objects/vanishing platforms/*");
if(vplatform.length()==0)
{
dlg("Error. There are no vanishing platforms available to view.");
resume_pools();
return;
}
else
{
string res=vplatsmenu();
if(res!="")
{
vplattyp=res;
}
}
input.set_only_allowed_chars("1234567890-");
string vol2=input.input("Enter the volume of this vanishing platform. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone2=input.input("Enter the pitch of this vanishing platform. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
string sp=input.input("Enter the speed of this vanishing platform.");
if(volume2=="" and pitch2=="" and speedtime=="")
return;
volume2=string_to_number(vol2);
pitch2=string_to_number(semitone2);
speedtime=string_to_number(sp);
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"vanishing_platform "+x+" "+paxx+" "+y+" "+tiletype+" "+volume+" "+pitch+" "+vplattyp+" "+volume2+" "+pitch2+" "+speedtime);
mapper.close();
spawn_vanishing_platform(x, paxx, y, y, tiletype, volume, pitch, vplattyp, volume2, pitch2, speedtime);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="wl")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this wall.");
string mx2=input.input("Enter the maximum x of this wall.");
string my=input.input("Enter the minimum y of this wall.");
string my2=input.input("Enter the maximum y of this wall.");
string hp=input.input("Enter the health of this wall.");
if(x=="" and paxx=="" and y=="" and paxy=="" and minhp=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
minhp=string_to_number(hp);
string[] border=find_directories("sounds/"+soundpack+"/objects/walls/*");
if(border.length()==0)
{
dlg("Error. There are no walls available to view.");
resume_pools();
return;
}
else
{
string res=wallsmenu();
if(res!="")
{
walltype=res;
}
input.set_only_allowed_chars("1234567890-");
string vol=input.input("Enter the volume of this wall. Press enter to use the default volume, or control backspace to clear the input to type your own volume.", "0");
string semitone=input.input("Enter the pitch of this wall. Press enter to use the default pitch, or control backspace to clear the input to type your own pitch.", "100");
if(volume=="" and pitch=="")
return;
volume=string_to_number(vol);
pitch=string_to_number(semitone);
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this wall to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"wall "+x+" "+paxx+" "+y+" "+paxy+" "+minhp+" "+walltype+" "+volume+" "+pitch+" "+dmd);
mapper.close();
spawn_wall(x, paxx, y, paxy, minhp, minhp, walltype, volume, pitch, dmd);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="zb")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the x of this zombie.");
string my=input.input("Enter the y of this zombie.");
string rng=input.input("Enter the horizontal range of this zombie.");
string rng2=input.input("Enter the vertical range of this zombie.");
string hp=input.input("Enter the health of this zombie.");
string hc=input.input("Enter the maximum lives of this zombie.");
string dm=input.input("Enter the maximum damage of this zombie.");
string ft=input.input("Enter the fire time of this zombie.");
string sp=input.input("Enter the speed of this zombie.");
string lev=input.input("Enter the level of this zombie.");
string exper=input.input("Enter the xp of this zombie.");
if(x=="" and y=="" and zombrange=="" and zombrange2=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
zombrange=string_to_number(rng);
zombrange2=string_to_number(rng2);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] zombie=find_directories("sounds/"+soundpack+"/npc/zombies/*");
if(zombie.length()==0)
{
dlg("Error. There are no zombies available to view.");
resume_pools();
return;
}
else
{
string res=zombiesmenu();
if(res!="")
{
zotype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the zombie attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the zombie move?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the zombie folow you up on other platforms?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"zombie "+x+" "+y+" "+zombrange+" "+zombrange2+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+zotype+" "+fb+" "+mb+" "+mb2);
mapper.close();
spawn_zombie(x, y, zombrange, zombrange2, minhp, minhp, card, damage, firetime, speedtime, lv, xn, zotype, fb, mb, mb2);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="zz")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this zombie zone.");
string mx2=input.input("Enter the maximum x of this zombie zone.");
string my=input.input("Enter the y of this zombie zone.");
string sp=input.input("Enter the spawn time of this zombie zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] zombie=find_directories("sounds/"+soundpack+"/npc/zombies/*");
if(zombie.length()==0)
{
dlg("Error. There are no zombies available to view.");
resume_pools();
return;
}
else
{
string res=zombiesmenu(true);
if(res!="")
{
zotype=res;
}
}
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"zombie_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+zotype);
mapper.close();
spawn_zombiezone(x, paxx, y, speedtime, zotype);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="zn")
{
input.set_only_allowed_chars("1234567890-");
string mx=input.input("Enter the minimum x of this zone.");
string mx2=input.input("Enter the maximum x of this zone.");
string my=input.input("Enter the minimum y of this zone.");
string my2=input.input("Enter the maximum y of this zone.");
input.set_only_allowed_chars("none");
string text=input.input("Enter the text of this zone.");
if(x=="" and paxx=="" and y=="" and paxy=="" and txt=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
txt=text;
resume_pools();
mapper.open("data/maps/"+mapname+".map","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"zone "+x+" "+paxx+" "+y+" "+paxy+" "+txt);
mapper.close();
spawn_zone(x, paxx, y, paxy, txt);
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="addline")
{
mapper.open("data/maps/"+mapname+".map", "ab");
mapdata=mapper.read();
input.set_only_allowed_chars("none");
string newline=input.input("Enter the line you'd like to add.");
resume_pools();
mapper.write("\r\n"+newline);
mapper.close();
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
if(buildem=="remline")
{
mapper.open("data/maps/"+mapname+".map", "rb");
mapdata=mapper.read();
string[] lines=string_split(mapdata, "\r\n", true);
string[] filtered_lines;
uint[] original_lines;
filter_empty_lines(lines, filtered_lines, original_lines);
setupmenu();
for (uint i=0; i<filtered_lines.length(); i++)
{
m.add_item_tts(filtered_lines[i],filtered_lines[i], "", true);
}
int mres=m.run("Select a line to remove", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres>3 and mres<=filtered_lines.length())
{
uint original_index=original_lines[mres-1];
lines.remove_at(original_index);
string final;
for (uint i=0; i<lines.length(); i++)
{
if(i>0) final+="\r\n";
final+=lines[i];
}
resume_pools();
mapper.open("data/maps/"+mapname+".map", "wb");
mapdata=mapper.read();
mapper.write(final);
mapper.close();
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
}
if(buildem=="editline")
{
mapper.open("data/maps/" + mapname + ".map", "rb");
mapdata=mapper.read();
mapper.close();
string[] lines=string_split(mapdata, "\r\n", true);
string[] filtered_lines;
uint[] original_lines;
filter_empty_lines(lines, filtered_lines, original_lines);
setupmenu();
for (uint i=0; i<filtered_lines.length(); i++)
{
m.add_item_tts(filtered_lines[i],filtered_lines[i], "", true);
}
int mres=m.run("Select a line to edit", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres>0 and mres<=filtered_lines.length())
{
uint original_index=original_lines[mres-1];
input.set_only_allowed_chars("none");
string final=input.input("line editor", lines[original_index]);
lines[original_index]=final; 
string mapline;
for (uint i=0; i<lines.length(); i++)
{
if(i>0) mapline+="\r\n";
mapline += lines[i];
}
resume_pools();
mapper.open("data/maps/" + mapname + ".map", "wb");
mapper.write(mapline);
mapper.close();
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
}
if(buildem=="dcm")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to delete the current map? This action can't be undone.",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
if(file_exists("data/maps/"+mapname+".map")) file_delete("data/maps/"+mapname+".map");
if(fademode==0) fade_multi_pool(0);
if(fademode==1) fade_multi_pool(1);
speak("map deleted");
me.x=0;
me.y=0;
clearmap();
destroymap();
mapmenu();
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
if(buildem=="clboard")
{
resume_pools();
mapper.open("data/maps/" + mapname + ".map", "rb");
mapdata=mapper.read();
clipboard_copy_text(mapdata);
speak("The data of "+mapname+" has been copied to your clipboard");
mapper.close();
}
if(buildem=="clboard2")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to overwrite all existing map data with what's on your clipboard?",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
resume_pools();
mapper.open("data/maps/" + mapname + ".map", "wb");
mapdata=mapper.read();
mapdata=clipboard_read_text();
if(mapdata=="") dlg("error. The map data you've pasted is invalid.");
else
{
resume_pools();
mapper.write(mapdata);
mapper.close();
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
if(buildem=="rcm")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to reload the current map?",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
resume_pools();
load_map(mapname);
speak("map reloaded");
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
}
void itemsmenu()
{
setupmenu();
m.add_item_tts("drinks", "refreshments");
m.add_item_tts("foods", "appatiser");
m.add_item_tts("healers", "medical");
m.add_item_tts("back", "back");
int mres=m.run("Items menu",true);
string itsm=m.get_item_name(mres);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(itsm=="refreshments")
{
string res=drinkmenu();
if(res!="")
{
drinktype=res;
drawable=false;
itemcad=1;
useitems=true;
}
}
if(itsm=="appatiser")
{
string res=foodmenu();
if(res!="")
{
foodtype=res;
drawable=false;
itemcad=2;
useitems=true;
}
}
if(itsm=="medical")
{
string res=healermenu();
if(res!="")
{
healtype=res;
drawable=false;
itemcad=3;
useitems=true;
}
}
if(itsm=="back")
{
resume_pools();
return;
}
}
void reverbmenu()
{
create_slider();
s.add_slider_item("dry_mix", 0.0, 1.0, 0.0, 0.1);
s.add_slider_item("wet_mix", 0.0, 1.0, 0.0, 0.1);
s.add_slider_item("room_size", 0.0, 1.0, 0.0, 0.1);
s.add_slider_item("damping", 0.0, 1.0, 0.0, 0.1);
s.add_slider_item("width", 0.0, 1.0, 0.0, 0.1);
int sres = s.run_slider("Reverb Designer. Press tab or shift tab to cycle through the reverb parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
revdry = s.get_item_value(0);
revwet = s.get_item_value(1);
revsize = s.get_item_value(2);
revdamp = s.get_item_value(3);
revwidth = s.get_item_value(4);
}
void weaponsmenu()
{
setupmenu();
m.add_item_tts("archery", "arro");
m.add_item_tts("artillery", "shoot");
m.add_item_tts("explosive", "bomb");
m.add_item_tts("melee", "swing");
m.add_item_tts("back", "back");
int mres=m.run("Weapons menu",true);
string wpsm=m.get_item_name(mres);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(wpsm=="arro")
{
string[] archers=find_directories("data/layouts/equipments/weapons/archery/*");
if(archers.length()==0)
{
dlg("Error. There are no archery weapons available to view.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
string[] arclist=find_directories("data/layouts/equipments/weapons/archery/*");
for(uint i=0; i<arclist.length(); i++)
{
arcparse(arclist[i]);
}
string res=archersmenu();
if(res!="")
{
drawable=true;
melee=false;
useitems=false;
weapontype="archery";
weapontype2=res;
}
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
if(wpsm=="shoot")
{
string[] fighters=find_directories("data/layouts/equipments/weapons/artillery/*");
if(fighters.length()==0)
{
dlg("Error. There are no artillery weapons available to view.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
string[] artlist=find_directories("data/layouts/equipments/weapons/artillery/*");
for(uint i=0; i<artlist.length(); i++)
{
artparse(artlist[i]);
}
string res=gunsmenu();
if(res!="")
{
drawable=true;
melee=false;
useitems=false;
weapontype="artillery";
weapontype2=res;
}
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
if(wpsm=="bomb")
{
string[] killers=find_directories("data/layouts/equipments/weapons/explosive/*");
if(killers.length()==0)
{
dlg("Error. There are no explosive weapons available to view.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
string[] exolist=find_directories("data/layouts/equipments/weapons/explosive/*");
for(uint i=0; i<exolist.length(); i++)
{
exoparse(exolist[i]);
}
string res=explosesmenu();
if(res!="")
{
drawable=true;
melee=false;
useitems=false;
weapontype="explosive";
weapontype2=res;
}
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
if(wpsm=="swing")
{
string[] brawlers=find_directories("data/layouts/equipments/weapons/melee/*");
if(brawlers.length()==0)
{
dlg("Error. There are no melee weapons available to view.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
string[] melelist=find_directories("data/layouts/equipments/weapons/melee/*");
for(uint i=0; i<melelist.length(); i++)
{
meleparse(melelist[i]);
}
string res=meleesmenu();
if(res!="")
{
drawable=true;
melee=true;
useitems=false;
weapontype="melee";
weapontype2=res;
}
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
if(wpsm=="back")
{
resume_pools();
return;
}
}
void objinfo()
{
string[] animaltype=find_directories("sounds/"+soundpack+"/npc/animals/*");
string[] enemytype=find_directories("sounds/"+soundpack+"/npc/enemies/*");
string[] projtype=find_directories("sounds/"+soundpack+"/npc/projectiles/*");
string[] robtype=find_directories("sounds/"+soundpack+"/npc/robots/*");
string[] spiketype=find_directories("sounds/"+soundpack+"/objects/spikes/*");
string[] turtype=find_directories("sounds/"+soundpack+"/npc/turrets/*");
string[] vehtype=find_directories("sounds/"+soundpack+"/objects/vehicles/*");
string[] zombtype=find_directories("sounds/"+soundpack+"/npc/zombies/*");
setupmenu();
m.add_item_tts("total objects "+(animals.length()+bullets.length()+doors.length()+enemies.length()+projectiles.length()+robots.length()+spikes.length()+turrets.length()+vehicles.length()+walls.length()+zombies.length()));
for(uint i=0; i<animals.length(); i++)
{
m.add_item_tts(animals[i].animaltype+";"+"at;"+animals[i].amx+";"+animals[i].amy+";"+"HP"+round(animals[i].animalhealth/animals[i].animalmaxhealth*100,2)+"percent"+";"+"level"+animals[i].amlevel);
}
for(uint i=0; i<bullets.length(); i++)
{
m.add_item_tts("bullet at;"+bullets[i].bullx+";"+bullets[i].bully);
}
for(uint i=0; i<doors.length(); i++)
{
m.add_item_tts("door at;"+doors[i].startx+";"+doors[i].starty+";"+"HP"+round(doors[i].doorhealth/doors[i].doormaxhealth*100,2)+"percent");
}
for(uint i=0; i<enemies.length(); i++)
{
m.add_item_tts(enemies[i].enemytype+";"+"at;"+enemies[i].emx+";"+enemies[i].emy+";"+"HP"+round(enemies[i].enemyhealth/enemies[i].enemymaxhealth*100,2)+"percent"+";"+"level"+enemies[i].emlevel);
}
for(uint i=0; i<projectiles.length(); i++)
{
m.add_item_tts(projectiles[i].projtype+";"+"at;"+projectiles[i].prox+";"+projectiles[i].proy+";"+"HP"+round(projectiles[i].projhealth/projectiles[i].projmaxhealth*100,2)+"percent"+";"+"level"+projectiles[i].projlevel);
}
for(uint i=0; i<robots.length(); i++)
{
m.add_item_tts(robots[i].robtype+";"+"at;"+robots[i].robx+";"+robots[i].roby+";"+"HP"+round(robots[i].robothealth/robots[i].robotmaxhealth*100,2)+"percent"+";"+"level"+robots[i].roblevel);
}
for(uint i=0; i<spikes.length(); i++)
{
m.add_item_tts(spikes[i].spiketype+";"+"at;"+spikes[i].minx+";"+spikes[i].miny+";"+"HP"+round(spikes[i].spikehealth/spikes[i].spikemaxhealth*100,2)+"percent");
}
for(uint i=0; i<turrets.length(); i++)
{
m.add_item_tts(turrets[i].turtype+";"+"at;"+turrets[i].turx+";"+turrets[i].tury+";"+"HP"+round(turrets[i].turhealth/turrets[i].turmaxhealth*100,2)+"percent"+";"+"level"+turrets[i].turlevel);
}
for(uint i=0; i<vehicles.length(); i++)
{
m.add_item_tts(vehicles[i].vehtype+";"+"at;"+vehicles[i].vehx+";"+vehicles[i].vehy+";"+"HP"+round(vehicles[i].vehhealth/vehicles[i].vehmaxhealth*100,2)+"percent");
}
for(uint i=0; i<walls.length(); i++)
{
m.add_item_tts(walls[i].wall+";"+"at;"+walls[i].minx+";"+walls[i].miny+";"+"HP"+round(walls[i].wallhealth/walls[i].wallmaxhealth*100,2)+"percent");
}
for(uint i=0; i<zombies.length(); i++)
{
m.add_item_tts(zombies[i].zombtype+";"+"at;"+zombies[i].zombx+";"+zombies[i].zomby+";"+"HP"+round(zombies[i].zombiehealth/zombies[i].zombiemaxhealth*100,2)+"percent"+";"+"level"+zombies[i].zomblevel);
}
int mres=m.run("Object info", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
resume_pools();
}
void pausemenu()
{
p.play_stationary("pause.ogg",false);
if(autosave==1) writedata();
pause_game();
setupmenu();
m.add_item_tts("resume game", "rmg");
m.add_item_tts("view statistics", "vs");
int mres=m.run("Pause menu. ",true);
string psmem=m.get_item_name(mres);
if(mres==0)
{
p.play_stationary("resume.ogg",false);
if(autosave==1) writedata();
resume_game();
return;
}
if(psmem=="rmg")
{
p.play_stationary("resume.ogg",false);
if(autosave==1) writedata();
resume_game();
return;
}
if(psmem=="vs")
{
statsmenu();
}
}
void statsmenu()
{
setupmenu();
if(gamemode==1) m.add_item_tts("there are;"+animals.length()+"animals spawned on the map.");
if(gamemode==2) m.add_item_tts("there are;"+enemies.length()+"enemies spawned on the map.");
if(gamemode==3) m.add_item_tts("there are;"+projectiles.length()+"projectiles spawned on the map.");
if(gamemode==4) m.add_item_tts("there are;"+robots.length()+"robots spawned on the map.");
if(gamemode==5) m.add_item_tts("there are;"+zombies.length()+"zombies spawned on the map.");
if(gamemode==6) m.add_item_tts("there are;"+animals.length()+amtype+";"+"spawned on the map.");
if(gamemode==7) m.add_item_tts("there are;"+enemies.length()+emtype+";"+"spawned on the map.");
if(gamemode==8) m.add_item_tts("there are;"+projectiles.length()+potype+";"+"spawned on the map.");
if(gamemode==9) m.add_item_tts("there are;"+robots.length()+rotype+";"+"spawned on the map.");
if(gamemode==10) m.add_item_tts("there are;"+zombies.length()+zotype+";"+"spawned on the map.");
if(me.y>=1  and gmt(me.x,me.y)=="") m.add_item_tts("current location,"+me.x+",;"+me.y+","+"you're currently in the air,"+"facing;"+facing);
else if(me.y>=0 ) m.add_item_tts("current location,"+me.x+",;"+me.y+","+"you're walking on;"+gmt(me.x,me.y)+","+"facing;"+facing);
if(lifecard>=2) m.add_item_tts("health, "+round(health/maxhealth*100,2)+"percent, "+health+"of "+maxhealth+"hitpoints remaining, with "+lifecard+"lives left.");
else if(lifecard<=1) m.add_item_tts("health, "+round(health/maxhealth*100,2)+"percent, "+health+"of "+maxhealth+"hitpoints remaining, with "+lifecard+"life left.");
if(shieldon==1) m.add_item_tts("shield strength, "+round(shieldstrength/maxshieldstrength*100,2)+"percent, "+shieldstrength+"of "+maxshieldstrength+"hitpoints remaining.");
m.add_item_tts("Your maximum jump height is"+jumpheight+"squares");
m.add_item_tts("Your maximum x position is"+maxx+"tiles");
m.add_item_tts("Your maximum y position is"+maxy+"tiles");
m.add_item_tts("You're currently on level"+level+"with"+xp+"experience. Your next level requires"+(xprequiered-xp)+"experience.");
m.add_item_tts("You have"+points+"points available to spend.");
if(melee==false) m.add_item_tts("you have "+loadedammo+" out of "+maxammo+" ammo loaded, and "+ammo+" ammo in reserve.");
m.add_item_tts("You have killed a total of"+kills+"enemies.");
m.add_item_tts("You've been playing for a total of;"+timeelapsed.m()+"minutes,"+timeelapsed.s()+"seconds");
m.add_item_tts("back","back");
int mres=m.run("Statistics menu. There are "+(m.get_item_count()-1)+" entries available to view.",true);
string stmem=m.get_item_name(mres);
if(mres==0)
{
pausemenu();
}
if(stmem=="back")
{
pausemenu();
}
}
void pointsmenu()
{
setupmenu();
m.add_item_tts("You're currently on level"+level+"with"+xp+"experience. Your next level requires"+(xprequiered-xp)+"experience.");
m.add_item_tts("You have"+points+"points available to spend.");
m.add_item_tts("upgrade maximum attack,"+"currently set to;"+attack, "umat");
m.add_item_tts("upgrade maximum defence,"+"currently set to;"+defence, "umd");
if(melee==false) m.add_item_tts("upgrade maximum ammo,"+"currently set to;"+maxammo, "uma");
m.add_item_tts("upgrade maximum health,"+"currently set to;"+maxhealth, "umh");
m.add_item_tts("upgrade maximum lives,"+"currently set to;"+lifecard, "umlf");
m.add_item_tts("upgrade maximum shield strength,"+"currently set to;"+maxshieldstrength, "umst");
m.add_item_tts("upgrade maximum shield defence,"+"currently set to;"+shielddefence, "umsd");
m.add_item_tts("upgrade maximum horizontal weapon range,"+"currently set to;"+weprange, "umra1");
m.add_item_tts("upgrade maximum vertical weapon range,"+"currently set to;"+weprange2, "umra2");
m.add_item_tts("back", "back");
int mres=m.run("Points menu. ",true);
string ptmem=m.get_item_name(mres);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(ptmem=="umat")
{
if(points<=0)
{
dlg("Error, you don't have enough points to complete this action.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string att=input.input("How much attack would you like to buy?");
if(attack=="")
return;
int tempstat=string_to_number(att);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
attack+=tempstat;
points-=tempstat;
update_char_attack("data/layouts/characters/"+chartype+"/"+chartype+".sif", attack);
}
}
if(ptmem=="umd")
{
if(points<=0)
{
dlg("Error, you don't have enough points to complete this action.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string def=input.input("How much defence would you like to buy?");
if(defence=="")
return;
int tempstat=string_to_number(def);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
defence+=tempstat;
points-=tempstat;
update_char_defence("data/layouts/characters/"+chartype+"/"+chartype+".sif", defence);
}
}
if(ptmem=="uma")
{
if(points<=0)
{
dlg("Error, you don't have enough points to complete this action.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string amm=input.input("How much ammo would you like to buy?");
if(ammo=="")
return;
int tempstat=string_to_number(amm);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
ammo+=tempstat;
points-=tempstat;
update_wep_ammo(weapontype, weapontype2, ammo);
}
}
if(ptmem=="umh")
{
if(points<=0)
{
dlg("Error, you don't have enough points to complete this action.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string hp=input.input("How much health would you like to buy?");
if(health=="")
return;
int tempstat=string_to_number(hp);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
maxhealth+=tempstat;
points-=tempstat;
update_char_maxhealth("data/layouts/characters/"+chartype+"/"+chartype+".sif", maxhealth);
}
}
if(ptmem=="umlf")
{
if(points<=0)
{
dlg("Error, you don't have enough points to complete this action.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string lc=input.input("How many lives would you like to buy?");
if(lifecard=="")
return;
int tempstat=string_to_number(lc);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
lifecard+=tempstat;
points-=tempstat;
update_char_lives("data/layouts/characters/"+chartype+"/"+chartype+".sif", lifecard);
}
}
if(ptmem=="umst")
{
if(points<=0)
{
dlg("Error, you don't have enough points to complete this action.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string sg=input.input("How much shield strength would you like to buy?");
if(maxshieldstrength=="")
return;
int tempstat=string_to_number(sg);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
maxshieldstrength+=tempstat;
points-=tempstat;
update_shield_max_strength("data/layouts/equipments/shields/"+shieldtype+"/"+shieldtype+".sif", maxshieldstrength);
}
}
if(ptmem=="umsd")
{
if(points<=0)
{
dlg("Error, you don't have enough points to complete this action.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string sd=input.input("How much shield defence would you like to buy?");
if(shielddefence=="")
return;
int tempstat=string_to_number(sd);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
shielddefence+=tempstat;
points-=tempstat;
update_shield_defence("data/layouts/equipments/shields/"+shieldtype+"/"+shieldtype+".sif", shielddefence);
}
}
if(ptmem=="umra1")
{
if(points<=0)
{
dlg("Error, you don't have enough points to complete this action.");
resume_pools();
return;
}
else if(points>=1)
{
input.set_only_allowed_chars("1234567890-");
string rg1=input.input("How much horizontal weapon range would you like to buy?");
if(weprange=="")
return;
int tempstat=string_to_number(rg1);
p.play_stationary("buy"+random(1,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
weprange+=tempstat;
points-=tempstat;
update_wep_hl_range(weapontype, weapontype2, weprange);
}
}
if(ptmem=="umra2")
{
if(points<=0)
{
dlg("Error, you don't have enough points to complete this action.");
resume_pools();
return;
}
else if(points>=2)
{
input.set_only_allowed_chars("1234567890-");
string rg2=input.input("How much vertical weapon range would you like to buy?");
if(weprange2=="")
return;
int tempstat=string_to_number(rg2);
p.play_stationary("buy"+random(2,4)+".ogg",false);
resume_pools();
speak("Perchis completed.");
weprange2+=tempstat;
points-=tempstat;
update_wep_vl_range(weapontype, weapontype2, weprange2);
}
}
if(ptmem=="back")
{
resume_pools();
return;
}
}
