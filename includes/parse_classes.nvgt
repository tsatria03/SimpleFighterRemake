bool string_file_encrypt(string input_file, string output_file, string key)
{
bool success;
file f;
success=f.open(input_file, "rb");
if(!success) return false;
string text=f.read();
text=string_encrypt(text, key);
if(text=="") return false;
success=f.open(output_file, "wb");
if(!success) return false;
f.write(text);
success=f.close();
return success;
}
bool string_file_decrypt(const string& input_file, const string& output_file, const string& encryption_key)
{
file input;
if (!input.open(input_file, "rb"))
return false;
string encrypted_content = input.read();
input.close();
string decrypted_content = string_decrypt(encrypted_content, encryption_key);
file output;
if (!output.open(output_file, "wb"))
return false;
output.write(decrypted_content);
output.close();
return true;
}
string file_decrypt(const string& encrypted_content, const string& encryption_key)
{
return string_decrypt(encrypted_content, encryption_key);
}
void charparse(const string&in path)
{
if(file_exists("data/layouts/characters/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/characters/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="shield type")
{
shieldtype=data[1];
}
if (data[0]=="shield weight")
{
shieldweight=parse_int(data[1]);
}
if (data[0]=="attack")
{
attack=parse_double(data[1]);
}
if (data[0]=="defence")
{
defence=parse_double(data[1]);
}
if (data[0]=="points")
{
points=parse_double(data[1]);
}
if (data[0]=="health")
{
health=parse_double(data[1]);
}
if (data[0]=="max health")
{
maxhealth=parse_double(data[1]);
}
if (data[0]=="lives")
{
lifecard=parse_double(data[1]);
}
if (data[0]=="level")
{
level=parse_double(data[1]);
}
if (data[0]=="level modifier")
{
levmod=parse_double(data[1]);
}
if (data[0]=="experience")
{
xp=parse_double(data[1]);
}
if (data[0]=="experience modifier")
{
xpmod=parse_double(data[1]);
}
if (data[0]=="experience required")
{
xprequiered=parse_double(data[1]);
}
if(data[0]=="cam sound")
{
charcamsound=parse_int(data[1]);
}
if(data[0]=="cam sound2")
{
charcamsound2=parse_int(data[1]);
}
if(data[0]=="death sound")
{
chardeathsound=parse_int(data[1]);
}
if(data[0]=="fall sound")
{
charfallsound=parse_int(data[1]);
}
if(data[0]=="fall sound2")
{
charfallsound2=parse_int(data[1]);
}
if(data[0]=="heal sound")
{
charhealsound=parse_int(data[1]);
}
if(data[0]=="heal sound2")
{
charhealsound2=parse_int(data[1]);
}
if(data[0]=="heal sound3")
{
charhealsound3=parse_int(data[1]);
}
if(data[0]=="hurt sound")
{
charhurtsound=parse_int(data[1]);
}
if(data[0]=="inv sound")
{
charinvsound=parse_int(data[1]);
}
if(data[0]=="jump sound")
{
charjumpsound=parse_int(data[1]);
}
if(data[0]=="jump sound2")
{
charjumpsound2=parse_int(data[1]);
}
if(data[0]=="land sound")
{
charlandsound=parse_int(data[1]);
}
if(data[0]=="kill sound")
{
charkillsound=parse_int(data[1]);
}
if(data[0]=="lev sound")
{
charlevsound=parse_int(data[1]);
}
if(data[0]=="life sound")
{
charlifesound=parse_int(data[1]);
}
if(data[0]=="rock sound")
{
charshakesound=parse_int(data[1]);
}
if(data[0]=="sit sound")
{
charsitsound=parse_int(data[1]);
}
if(data[0]=="stand sound")
{
charstandsound=parse_int(data[1]);
}
if(data[0]=="swing sound")
{
charswingsound=parse_int(data[1]);
}
if(data[0]=="turn sound")
{
charturnsound=parse_int(data[1]);
}
}
add_character(name, shieldtype, shieldweight, attack, defence, points, health, maxhealth, lifecard, level, levmod, xp, xpmod, xprequiered, charcamsound, charcamsound2, chardeathsound, charfallsound, charfallsound2, charhealsound, charhealsound2, charhealsound3, charhurtsound, charinvsound, charjumpsound, charjumpsound2, charkillsound, charlandsound, charlevsound, charlifesound, charshakesound, charsitsound, charstandsound, charswingsound, charturnsound);
}
}
void arcparse(const string&in path)
{
if(file_exists("data/layouts/equipments/weapons/archery/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/equipments/weapons/archery/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="damage")
{
wepdamage=parse_int(data[1]);
}
if (data[0]=="mode")
{
wephold=parse_int(data[1]);
}
if (data[0]=="horizontal range")
{
weprange=parse_int(data[1]);
}
if (data[0]=="vertical range")
{
weprange2=parse_int(data[1]);
}
if (data[0]=="bullet speed")
{
wepspeed=parse_int(data[1]);
}
if (data[0]=="repeat time")
{
weapontime=parse_int(data[1]);
}
if (data[0]=="spam time")
{
weapontime2=parse_int(data[1]);
}
if (data[0]=="weight")
{
wepweight=parse_int(data[1]);
}
if (data[0]=="ammo")
{
ammo=parse_double(data[1]);
}
if (data[0]=="loaded ammo")
{
loadedammo=parse_double(data[1]);
}
if (data[0]=="max ammo")
{
maxammo=parse_double(data[1]);
}
if (data[0]=="unlock level")
{
weplevel=parse_double(data[1]);
}
if(data[0]=="draw sound")
{
wepdrawsound=parse_int(data[1]);
}
if(data[0]=="empty sound")
{
wepemptysound=parse_int(data[1]);
}
if(data[0]=="fire sound")
{
wepfiresound=parse_int(data[1]);
}
if(data[0]=="hit sound")
{
wephitsound=parse_int(data[1]);
}
if(data[0]=="loop sound")
{
weploopsound=parse_int(data[1]);
}
if(data[0]=="rec sound")
{
weprecsound=parse_int(data[1]);
}
if(data[0]=="reload sound")
{
wepreloadsound=parse_int(data[1]);
}
if(data[0]=="shell sound")
{
wepshellsound=parse_int(data[1]);
}
}
add_weapon(name, wepdamage, wephold, weprange, weprange2, wepspeed, weapontime, weapontime2, wepweight, ammo, loadedammo, maxammo, weplevel, wepdrawsound, wepemptysound, wepfiresound, wephitsound, weploopsound, weprecsound, wepreloadsound, wepshellsound);
}
}
void artparse(const string&in path)
{
if(file_exists("data/layouts/equipments/weapons/artillery/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/equipments/weapons/artillery/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="damage")
{
wepdamage=parse_int(data[1]);
}
if (data[0]=="mode")
{
wephold=parse_int(data[1]);
}
if (data[0]=="horizontal range")
{
weprange=parse_int(data[1]);
}
if (data[0]=="vertical range")
{
weprange2=parse_int(data[1]);
}
if (data[0]=="bullet speed")
{
wepspeed=parse_int(data[1]);
}
if (data[0]=="repeat time")
{
weapontime=parse_int(data[1]);
}
if (data[0]=="spam time")
{
weapontime2=parse_int(data[1]);
}
if (data[0]=="weight")
{
wepweight=parse_int(data[1]);
}
if (data[0]=="ammo")
{
ammo=parse_double(data[1]);
}
if (data[0]=="loaded ammo")
{
loadedammo=parse_double(data[1]);
}
if (data[0]=="max ammo")
{
maxammo=parse_double(data[1]);
}
if (data[0]=="unlock level")
{
weplevel=parse_double(data[1]);
}
if(data[0]=="draw sound")
{
wepdrawsound=parse_int(data[1]);
}
if(data[0]=="empty sound")
{
wepemptysound=parse_int(data[1]);
}
if(data[0]=="fire sound")
{
wepfiresound=parse_int(data[1]);
}
if(data[0]=="hit sound")
{
wephitsound=parse_int(data[1]);
}
if(data[0]=="loop sound")
{
weploopsound=parse_int(data[1]);
}
if(data[0]=="rec sound")
{
weprecsound=parse_int(data[1]);
}
if(data[0]=="reload sound")
{
wepreloadsound=parse_int(data[1]);
}
if(data[0]=="shell sound")
{
wepshellsound=parse_int(data[1]);
}
}
add_weapon(name, wepdamage, wephold, weprange, weprange2, wepspeed, weapontime, weapontime2, wepweight, ammo, loadedammo, maxammo, weplevel, wepdrawsound, wepemptysound, wepfiresound, wephitsound, weploopsound, weprecsound, wepreloadsound, wepshellsound);
}
}
void exoparse(const string&in path)
{
if(file_exists("data/layouts/equipments/weapons/explosive/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/equipments/weapons/explosive/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="damage")
{
wepdamage=parse_int(data[1]);
}
if (data[0]=="mode")
{
wephold=parse_int(data[1]);
}
if (data[0]=="horizontal range")
{
weprange=parse_int(data[1]);
}
if (data[0]=="vertical range")
{
weprange2=parse_int(data[1]);
}
if (data[0]=="bullet speed")
{
wepspeed=parse_int(data[1]);
}
if (data[0]=="repeat time")
{
weapontime=parse_int(data[1]);
}
if (data[0]=="spam time")
{
weapontime2=parse_int(data[1]);
}
if (data[0]=="weight")
{
wepweight=parse_int(data[1]);
}
if (data[0]=="ammo")
{
ammo=parse_double(data[1]);
}
if (data[0]=="loaded ammo")
{
loadedammo=parse_double(data[1]);
}
if (data[0]=="max ammo")
{
maxammo=parse_double(data[1]);
}
if (data[0]=="unlock level")
{
weplevel=parse_double(data[1]);
}
if(data[0]=="draw sound")
{
wepdrawsound=parse_int(data[1]);
}
if(data[0]=="empty sound")
{
wepemptysound=parse_int(data[1]);
}
if(data[0]=="fire sound")
{
wepfiresound=parse_int(data[1]);
}
if(data[0]=="hit sound")
{
wephitsound=parse_int(data[1]);
}
if(data[0]=="loop sound")
{
weploopsound=parse_int(data[1]);
}
if(data[0]=="rec sound")
{
weprecsound=parse_int(data[1]);
}
if(data[0]=="reload sound")
{
wepreloadsound=parse_int(data[1]);
}
if(data[0]=="shell sound")
{
wepshellsound=parse_int(data[1]);
}
}
add_weapon(name, wepdamage, wephold, weprange, weprange2, wepspeed, weapontime, weapontime2, wepweight, ammo, loadedammo, maxammo, weplevel, wepdrawsound, wepemptysound, wepfiresound, wephitsound, weploopsound, weprecsound, wepreloadsound, wepshellsound);
}
}
void meleparse(const string&in path)
{
if(file_exists("data/layouts/equipments/weapons/melee/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/equipments/weapons/melee/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="damage")
{
wepdamage=parse_int(data[1]);
}
if (data[0]=="mode")
{
wephold=parse_int(data[1]);
}
if (data[0]=="horizontal range")
{
weprange=parse_int(data[1]);
}
if (data[0]=="vertical range")
{
weprange2=parse_int(data[1]);
}
if (data[0]=="bullet speed")
{
wepspeed=parse_int(data[1]);
}
if (data[0]=="repeat time")
{
weapontime=parse_int(data[1]);
}
if (data[0]=="spam time")
{
weapontime2=parse_int(data[1]);
}
if (data[0]=="weight")
{
wepweight=parse_int(data[1]);
}
if (data[0]=="ammo")
{
ammo=parse_double(data[1]);
}
if (data[0]=="loaded ammo")
{
loadedammo=parse_double(data[1]);
}
if (data[0]=="max ammo")
{
maxammo=parse_double(data[1]);
}
if (data[0]=="unlock level")
{
weplevel=parse_double(data[1]);
}
if(data[0]=="draw sound")
{
wepdrawsound=parse_int(data[1]);
}
if(data[0]=="empty sound")
{
wepemptysound=parse_int(data[1]);
}
if(data[0]=="fire sound")
{
wepfiresound=parse_int(data[1]);
}
if(data[0]=="hit sound")
{
wephitsound=parse_int(data[1]);
}
if(data[0]=="loop sound")
{
weploopsound=parse_int(data[1]);
}
if(data[0]=="rec sound")
{
weprecsound=parse_int(data[1]);
}
if(data[0]=="reload sound")
{
wepreloadsound=parse_int(data[1]);
}
if(data[0]=="shell sound")
{
wepshellsound=parse_int(data[1]);
}
}
add_weapon(name, wepdamage, wephold, weprange, weprange2, wepspeed, weapontime, weapontime2, wepweight, ammo, loadedammo, maxammo, weplevel, wepdrawsound, wepemptysound, wepfiresound, wephitsound, weploopsound, weprecsound, wepreloadsound, wepshellsound);
}
}
void shieldparse(const string&in path)
{
if(file_exists("data/layouts/equipments/shields/"+path+"/"+path+".sif"))
{
bool success=info.open("data/layouts/equipments/shields/"+path+"/"+path+".sif", "rb");
if(!success)
{
alert("Fatal error", "character "+path+" must have no info.set file!");
mainmenu();
}
string content=info.read();
string[] lines=string_split(content,"\r\n",true);
for(uint i=0; i<lines.length(); i++)
{
string[] data=string_split(lines[i],"=",true);
if (data.length()<2)
{
alert("Error","Error reading line "+(i+1)+".");
mainmenu();
}
if (data[0]=="name")
{
name=data[1];
}
if (data[0]=="defence")
{
shielddefence=parse_int(data[1]);
}
if (data[0]=="weight")
{
shieldweight=parse_int(data[1]);
}
if (data[0]=="shield strength")
{
shieldstrength=parse_int(data[1]);
}
if (data[0]=="max shield strength")
{
maxshieldstrength=parse_int(data[1]);
}
if (data[0]=="unlock level")
{
shieldlevel=parse_double(data[1]);
}
if(data[0]=="break sound")
{
shieldbreaksound=parse_int(data[1]);
}
if(data[0]=="draw sound")
{
shielddrawsound=parse_int(data[1]);
}
if(data[0]=="hit sound")
{
shieldhitsound=parse_int(data[1]);
}
if(data[0]=="loop sound")
{
shieldloopsound=parse_int(data[1]);
}
if(data[0]=="remove sound")
{
shieldremovesound=parse_int(data[1]);
}
if(data[0]=="wear sound")
{
shieldwearsound=parse_int(data[1]);
}
}
add_shield(name, shielddefence, shieldweight, shieldstrength, maxshieldstrength, shieldlevel, shieldbreaksound, shielddrawsound, shieldhitsound, shieldloopsound, shieldremovesound, shieldwearsound);
}
}
void update_char_attack(const string& filename, double new_attack) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();        
        int attack_pos = string_contains(content, "attack=", 1);
        if (attack_pos != -1) {
            int value_start = attack_pos + 7;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_attack = string_trim_sides(content.substr(value_start, value_end));            
            string old_value = "attack=" + current_attack;
            string new_value = "attack=" + string(new_attack);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Attack stat updated successfully.");
                } else {
                    speak("Failed to write updated attack stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Attack stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}
void update_char_defence(const string& filename, double new_defence) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int defence_pos = string_contains(content, "defence=", 1);
        if (defence_pos != -1) {
            int value_start = defence_pos + 8;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_defence = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "defence=" + current_defence;
            string new_value = "defence=" + string(new_defence);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Defence stat updated successfully.");
                } else {
                    speak("Failed to write updated defence stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Defence stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}
void update_char_maxhealth(const string& filename, double new_maxhealth) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int maxhealth_pos = string_contains(content, "max health=", 1);
        if (maxhealth_pos != -1) {
            int value_start = maxhealth_pos + 11;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_maxhealth = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "max health=" + current_maxhealth;
            string new_value = "max health=" + string(new_maxhealth);
            content = string_replace(content, old_value, new_value, true);
            int health_pos = string_contains(content, "health=", 1);
            if (health_pos != -1) {
                value_start = health_pos + 7;
                value_end = string_contains(content.substr(value_start), "\r\n", 1);
                if (value_end == -1) value_end = content.length() - value_start;
                string current_health = string_trim_sides(content.substr(value_start, value_end));
                old_value = "health=" + current_health;
                new_value = "health=" + string(new_maxhealth);
                content = string_replace(content, old_value, new_value, true);
            }
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Max health and health stats updated successfully.");
                } else {
                    speak("Failed to write updated health stats to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Max health stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}
void update_char_lives(const string& filename, double new_lives) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();        
        int lives_pos = string_contains(content, "lives=", 1);
        if (lives_pos != -1) {
            int value_start = lives_pos + 6;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_lives = string_trim_sides(content.substr(value_start, value_end));            
            string old_value = "lives=" + current_lives;
            string new_value = "lives=" + string(new_lives);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("lives stat updated successfully.");
                } else {
                    speak("Failed to write updated lives stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("lives stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}
void update_wep_ammo(const string& weapontype, const string& weapontype2, double new_ammo) {
    string filename = "data/layouts/equipments/weapons/" + weapontype + "/" + weapontype2 + "/" + weapontype2 + ".sif";
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int ammo_pos = string_contains(content, "ammo=", 1);
        if (ammo_pos != -1) {
            int value_start = ammo_pos + 5;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_ammo = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "ammo=" + current_ammo;
            string new_value = "ammo=" + string(new_ammo);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Ammo stat updated successfully.");
                } else {
                    speak("Failed to write updated ammo stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Ammo stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading: " + filename);
    }
}
void update_wep_hl_range(const string& weapontype, const string& weapontype2, int new_hl_range) {
    string filename = "data/layouts/equipments/weapons/" + weapontype + "/" + weapontype2 + "/" + weapontype2 + ".sif";
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int range_pos = string_contains(content, "horizontal range=", 1);
        if (range_pos != -1) {
            int value_start = range_pos + 17;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_hl_range = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "horizontal range=" + current_hl_range;
            string new_value = "horizontal range=" + string(new_hl_range);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Horizontal range stat updated successfully.");
                } else {
                    speak("Failed to write updated horizontal range stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Horizontal range stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading: " + filename);
    }
}
void update_wep_vl_range(const string& weapontype, const string& weapontype2, int new_vl_range) {
    string filename = "data/layouts/equipments/weapons/" + weapontype + "/" + weapontype2 + "/" + weapontype2 + ".sif";
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int range_pos = string_contains(content, "vertical range=", 1);
        if (range_pos != -1) {
            int value_start = range_pos + 15;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_vl_range = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "vertical range=" + current_vl_range;
            string new_value = "vertical range=" + string(new_vl_range);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Vertical range stat updated successfully.");
                } else {
                    speak("Failed to write updated vertical range stat to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Vertical range stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading: " + filename);
    }
}
void update_shield_max_strength(const string& filename, double new_max_strength) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int max_strength_pos = string_contains(content, "max shield strength=", 1);
        if (max_strength_pos != -1) {
            int value_start = max_strength_pos + 20;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_max_strength = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "max shield strength=" + current_max_strength;
            string new_value = "max shield strength=" + string(new_max_strength);
            content = string_replace(content, old_value, new_value, true);
            int strength_pos = string_contains(content, "shield strength=", 1);
            if (strength_pos != -1) {
                value_start = strength_pos + 16;
                value_end = string_contains(content.substr(value_start), "\r\n", 1);
                if (value_end == -1) value_end = content.length() - value_start;
                string current_strength = string_trim_sides(content.substr(value_start, value_end));
                old_value = "shield strength=" + current_strength;
                new_value = "shield strength=" + string(new_max_strength);
                content = string_replace(content, old_value, new_value, true);
            }
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Max shield strength and shield strength stats updated successfully.");
                } else {
                    speak("Failed to write updated shield strength stats to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Max shield strength stat not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}
void update_shield_defence(const string& filename, double new_shield_defence) {
    if (info.open(filename, "r")) {
        string content = info.read();
        info.close();
        int shield_defence_pos = string_contains(content, "defence=", 1);
        if (shield_defence_pos != -1) {
            int value_start = shield_defence_pos + 8;
            int value_end = string_contains(content.substr(value_start), "\r\n", 1);
            if (value_end == -1) value_end = content.length() - value_start;
            string current_shield_defence = string_trim_sides(content.substr(value_start, value_end));
            string old_value = "defence=" + current_shield_defence;
            string new_value = "defence=" + string(new_shield_defence);
            content = string_replace(content, old_value, new_value, true);
            if (info.open(filename, "w")) {
                uint bytes_written = info.write(content);
                info.close();
                if (bytes_written == content.length()) {
                    speak("Shield defence updated successfully.");
                } else {
                    speak("Failed to write updated shield defence to file.");
                }
            } else {
                speak("Failed to open file for writing.");
            }
        } else {
            speak("Shield defence not found in file.");
        }
    } else {
        speak("Failed to open file for reading.");
    }
}

character@ get_default_char()
{
if(charas.is_empty())
{
return null;
}
for(uint i=0; i<charas.length(); i++)
{
if(charas[i].name == chartype)
{
return charas[i];
}
}
return null;
}
shield@ get_default_shield()
{
if(shields.is_empty())
{
return null;
}
for(uint i=0; i<shields.length(); i++)
{
if(shields[i].name=="large shield")
{
return shields[i];
}
}
return null;
}
weapon@ get_default_weapon()
{
if(weapons.is_empty())
{
return null;
}
for(uint i=0; i<weapons.length(); i++)
{
if(weapons[i].name=="fist")
{
return weapons[i];
}
}
return null;
}

class parsed_data
{
string[] peramitors;
string[] values;
string source;
string decryption_key;
parsed_data(string text,string decryption_key,bool filename=true)
{
source=text;
this.decryption_key=decryption_key;
if(filename)
{
parse_data_from_file();
}
else
{
parse_data_from_string();
}
}
void parse_data_from_file()
{
file f;
bool success=f.open(source,"rb");
if(!success)
return;
else
{
string d;
if(decryption_key!="")
d=string_decrypt(f.read(),decryption_key);
else
d=f.read();
string[] parseddata=string_split(d,"\r\n",true);
for(int i=0; i<parseddata.length(); i++)
{
string[] parseddata2=string_split(parseddata[i],"=",true);
if(parseddata2.length()!=2)
continue;
else
{
peramitors.insert_last(parseddata2[0]);
values.insert_last(parseddata2[1]);
}
}
}
}
void parse_data_from_string()
{
string d;
if(decryption_key!="")
d=string_decrypt(source,decryption_key);
else
d=source;
string[] parseddata=string_split(d,"\r\n",true);
for(int i=0; i<parseddata.length(); i++)
{
string[] parseddata2=string_split(parseddata[i],"=",true);
if(parseddata2.length()!=2)
continue;
else
{
peramitors.insert_last(parseddata2[0]);
values.insert_last(parseddata2[1]);
}
}
}
string get_value(string peramitor)
{
if(peramitors.find(peramitor)!=-1)
return values[peramitors.find(peramitor)];
else
return "";
}
}

character@[]charas(0);
class character
{
string name;
string shieldtype;
int shieldweight;
double attack;
double defence;
double points;
double health;
double maxhealth;
double lifecard;
double level;
double levmod;
double xp;
double xpmod;
double xprequiered;
int charcamsound;
int charcamsound2;
int chardeathsound;
int charfallsound;
int charfallsound2;
int charhurtsound;
int charhealsound;
int charhealsound2;
int charhealsound3;
int charinvsound;
int charjumpsound;
int charjumpsound2;
int charkillsound;
int charlandsound;
int charlevsound;
int charlifesound;
int charshakesound;
int charsitsound;
int charstandsound;
int charswingsound;
int charturnsound;
character(const string&in name,const string&in shieldtype,int shieldweight,double attack,double defence,double points,double health,double maxhealth,double lifecard,double level,double levmod,double xp,double xpmod,double xprequiered,int charcamsound,int charcamsound2,int chardeathsound,int charfallsound,int charfallsound2,int charhealsound,int charhealsound2,int charhealsound3,int charhurtsound,int charinvsound,int charjumpsound,int charjumpsound2,int charkillsound,int charlandsound,int charlevsound,int charlifesound,int charshakesound,int charsitsound,int charstandsound,int charswingsound,int charturnsound)
{
this.name=name;
this.shieldtype=shieldtype;
this.shieldweight=shieldweight;
this.attack=attack;
this.defence=defence;
this.points=points;
this.health=health;
this.maxhealth=maxhealth;
this.lifecard=lifecard;
this.level=level;
this.levmod=levmod;
this.xp=xp;
this.xpmod=xpmod;
this.xprequiered=xprequiered;
this.charcamsound=charcamsound;
this.charcamsound2=charcamsound2;
this.chardeathsound=chardeathsound;
this.charfallsound=charfallsound;
this.charfallsound2=charfallsound2;
this.charhurtsound=charhurtsound;
this.charhealsound=charhealsound;
this.charhealsound2=charhealsound2;
this.charhealsound3=charhealsound3;
this.charinvsound=charinvsound;
this.charjumpsound=charjumpsound;
this.charjumpsound2=charjumpsound2;
this.charkillsound=charkillsound;
this.charlandsound=charlandsound;
this.charlevsound=charlevsound;
this.charlifesound=charlifesound;
this.charshakesound=charshakesound;
this.charsitsound=charsitsound;
this.charstandsound=charstandsound;
this.charswingsound=charswingsound;
this.charturnsound=charturnsound;
}
}
void add_character(const string&in name,const string&in shieldtype,int shieldweight,double attack,double defence,double points,double health,double maxhealth,double lifecard,double level,double levmod,double xp,double xpmod,double xprequiered,int charcamsound,int charcamsound2,int chardeathsound,int charfallsound,int charfallsound2,int charhealsound,int charhealsound2,int charhealsound3,int charhurtsound,int charinvsound,int charjumpsound,int charjumpsound2,int charkillsound,int charlandsound,int charlevsound,int charlifesound,int charshakesound,int charsitsound,int charstandsound,int charswingsound,int charturnsound)
{
character ch1(name,shieldtype,shieldweight,attack,defence,points,health,maxhealth,lifecard,level,levmod,xp,xpmod,xprequiered,charcamsound,charcamsound2,chardeathsound,charfallsound,charfallsound2,charhealsound,charhealsound2,charhealsound3,charhurtsound,charinvsound,charjumpsound,charjumpsound2,charkillsound,charlandsound,charlevsound,charlifesound,charshakesound,charsitsound,charstandsound,charswingsound,charturnsound);
charas.insert_last(ch1);
}
void destroy_all_charas()
{
charas.resize(0);
}

shield@[]shields(0);
class shield
{
string name;
double shielddefence;
int shieldweight;
double shieldstrength;
double maxshieldstrength;
double shieldlevel;
int shieldbreaksound;
int shielddrawsound;
int shieldhitsound;
int shieldloopsound;
int shieldremovesound;
int shieldwearsound;
shield(const string&in name,double shielddefence,int shieldweight,double shieldstrength,double maxshieldstrength,double shieldlevel,int shieldbreaksound,int shielddrawsound,int shieldhitsound,int shieldloopsound,int shieldremovesound,int shieldwearsound)
{
this.name=name;
this.shielddefence=shielddefence;
this.shieldweight=shieldweight;
this.shieldstrength=shieldstrength;
this.maxshieldstrength=maxshieldstrength;
this.shieldlevel=shieldlevel;
this.shieldbreaksound=shieldbreaksound;
this.shielddrawsound=shielddrawsound;
this.shieldhitsound=shieldhitsound;
this.shieldloopsound=shieldloopsound;
this.shieldremovesound=shieldremovesound;
this.shieldwearsound=shieldwearsound;
}
}
void add_shield(const string&in name,double shielddefence,int shieldweight,double shieldstrength,double maxshieldstrength,double shieldlevel,int shieldbreaksound,int shielddrawsound,int shieldhitsound,int shieldloopsound,int shieldremovesound,int shieldwearsound)
{
shield sl1(name,shielddefence,shieldweight,shieldstrength,maxshieldstrength,shieldlevel,shieldbreaksound,shielddrawsound,shieldhitsound,shieldloopsound,shieldremovesound,shieldwearsound);
shields.insert_last(sl1);
}
void destroy_all_shields()
{
shields.resize(0);
}

weapon@[]weapons(0);
class weapon
{
string name;
int wepdamage;
int wephold;
int weprange;
int weprange2;
int wepspeed;
int weapontime;
int weapontime2;
int wepweight;
double ammo;
double loadedammo;
double maxammo;
double weplevel;
int wepdrawsound;
int wepemptysound;
int wepfiresound;
int wephitsound;
int weploopsound;
int weprecsound;
int wepreloadsound;;
int wepshellsound;
weapon(const string&in name,int wepdamage,int wephold,int weprange,int weprange2,int wepspeed,int weapontime,int weapontime2,int wepweight,double ammo,double loadedammo,double maxammo,double weplevel,int wepdrawsound,int wepemptysound,int wepfiresound,int wephitsound,int weploopsound,int weprecsound,int wepreloadsound,int wepshellsound)
{
this.name=name;
this.wepdamage=wepdamage;
this.wephold=wephold;
this.weprange=weprange;
this.weprange2=weprange2;
this.wepspeed=wepspeed;
this.weapontime=weapontime;
this.weapontime2=weapontime2;
this.wepweight=wepweight;
this.ammo=ammo;
this.loadedammo=loadedammo;
this.maxammo=maxammo;
this.weplevel=weplevel;
this.wepdrawsound=wepdrawsound;
this.wepemptysound=wepemptysound;
this.wepfiresound=wepfiresound;
this.wephitsound=wephitsound;
this.weploopsound=weploopsound;
this.weprecsound=weprecsound;
this.wepreloadsound=wepreloadsound;
this.wepshellsound=wepshellsound;
}
}
void add_weapon(const string&in name,int wepdamage,int wephold,int weprange,int weprange2,int wepspeed,int weapontime,int weapontime2,int wepweight,double ammo,double loadedammo,double maxammo,double weplevel,int wepdrawsound,int wepemptysound,int wepfiresound,int wephitsound,int weploopsound,int weprecsound,int wepreloadsound,int wepshellsound)
{
weapon wp1(name,wepdamage,wephold,weprange,weprange2,wepspeed,weapontime,weapontime2,wepweight,ammo,loadedammo,maxammo,weplevel,wepdrawsound,wepemptysound,wepfiresound,wephitsound,weploopsound,weprecsound,wepreloadsound,wepshellsound);
weapons.insert_last(wp1);
}
void destroy_all_weapons()
{
weapons.resize(0);
}
